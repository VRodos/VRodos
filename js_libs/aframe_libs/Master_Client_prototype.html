<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="utf-8"/>
    <title>ŒñœâŒΩœÑŒ±ŒΩŒÆ Œ†Œ±œÅŒ¨œÉœÑŒ±œÉŒ∑</title>
    <meta name="description" content="Dev Example ‚Äî Networked-Aframe with Green Screen effect"/>

    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <script src="js/aframe/1.3.0/aframe.min.js"></script>
    <script src="js/socketio/2.3.0/socket.io.slim.js"></script>
    <script src="js/datgui/0.7.7/dat.gui.min.js"></script>

    <script src="../easyrtc/easyrtc.js"></script>
    <script src="../dist/networked-aframe.js"></script>

    <script src="js/a-water_alphamask_master.js"></script>
    <script src="js/sunsky/3.0.3/aframe-sun-sky.min.js"></script>
    <script src="js/randomizer/3.0.1/aframe-randomizer-components.min.js"></script>

    <script src="js/particles/aframe-particle-system-component.min.js"></script>

    <script src="js/spawn-in-circle.component.js"></script>

    <link rel="stylesheet" type="text/css" href="css/adv-screen.css" />
</head>
<body id="master-client-body">

<script>
    AFRAME.registerComponent('clear-frustum-culling', {
        init: function(){
            let el = this.el;
            el.addEventListener("model-loaded", e =>{
                let mesh = el.getObject3D('mesh');
                if (!mesh){return;}
                mesh.traverse(function(node){
                    if (node.isMesh){
                        node.frustumCulled = false;
                    }
                });
            });
        }
    });

    AFRAME.registerComponent('static-mask-me', {
        init: function(){
            let el = this.el;
            // el.addEventListener("model-loaded", e => {
            const maskMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: false,
                colorWrite: false,
            });
            maskMaterial.needsUpdate = true;
            let mesh = el.getObject3D('mesh');
            if (!mesh) {
                return;
            }
            mesh.traverse( node => {
                if(!node.isMesh){
                    return;
                }
                node.material = maskMaterial;
                node.renderOrder = 999;
            });
            //  });
        },
        tick: null
    });

    AFRAME.registerComponent('render-order-change', {
        schema: {
            renderingOrderArg: {type: 'string', default: '2000'}
        },
        init: function(){
            let el = this.el;
            // el.addEventListener("model-loaded", e => {
            let mesh = el.getObject3D('mesh');
            if (!mesh) {
                return;
            }
            mesh.traverse( node => {
                if(!node.isMesh){
                    return;
                }
                node.renderOrder = this.data.renderingOrderArg;

            });
            //  });
        },
        tick: null
    });
</script>

<div>
    <div class="wrapperVideoElement">
        <video id="video-preview" width="300" height="200" autoplay muted hidden></video>
        <video id="recording" hidden></video>
    </div>

    <div class="actionsDirector" name="actionsDiv" id="actionsDiv">
        <div id="toggle_controls">Close <span style="color: white">("x" button to show again)</span></div>
        <div id="directorline" style=""></div>


        <div class="wrapperControlElement">
            <label
                    for="roomNameShow"
                    title="Name of Room">&#127917;</label>
            <span id="roomNameShow">roomname</span>
        </div>

        <div class="wrapperControlElement">
            <label for="occupantsNumberShow" title="Number of actors">&#128101;</label>
            <span id="occupantsNumberShow"></span>
        </div>

        <div class="wrapperControlElement">
            <button id="obtainStatusAndSetSizeControls"
                    class="buttonMultiplaying"
                    title="Obtain status and control green screens">
                &#128260;  &#9989;
            </button>
        </div>

        <div class="wrapperControlElement">
            <button id="screen-btn-sendscreen"
                    class="buttonMultiplaying"
                    title="Send scene stream back to actors">
                &#127909; &#9654; &#128101;
            </button>
        </div>

        <div class="wrapperControlLineElement">
            <button id="start-recording-btn"
                    class="buttonStartRecord"
                    title="Start capturing video">
                ‚ö™Ô∏è
            </button>

            <button id="stop-recording-btn"
                    class="buttonStopRecord"
                    title="Save capture"
                    disabled >
                ‚óºÔ∏è
            </button>

            <a id="download-recording-btn"
               class="buttonDownloadRecording"
               title="Download video"
               disabled >
                üíæÔ∏èÔ∏è
            </a>

            <button id="upload-recording-btn"
                    class="buttonUploadRecording"
                    style="visibility: hidden"
                    title="Upload Recording to MediaVerse"
                    disabled >
                ‚¨ÜÔ∏èÔ∏èÔ∏è
            </button>
        </div>
        <div class="wrapperControlElement">
            <span id="captured-video-label"></span>
        </div>
        <div class="wrapperControlElement">
            <label for="positionShow" title="Camera Position">&#127909;</label>
            <span id="positionShow"></span>
        </div>

        <div id="panelsSizeControlsDiv"></div>
        <input id="node-url-input" hidden disabled />
        <input id="node-token-input" hidden disabled />
        <input id="mv-project-id-input" hidden disabled />
    </div>
</div>


<a-scene
        id="aframe-scene-container"
        fog="type: linear; color: #AAB; far: 230; near: 0"
        renderer="antialias: true; sortObjects: true; toneMapping: ACESFilmic"
        background="color: #000000"
        vr-mode-ui="enabled: false"
        networked-scene="
        room: roomname;
        debug: true;
        adapter: easyrtc;
        audio: true;
        video: true;">
    <a-entity cursor="rayOrigin:mouse"></a-entity>
    <a-assets>
        <!-- Avatar Template -->
        <template id="avatar-template">
            <a-entity class="avatar"
                      networked-audio-source>

                <a-plane id="videoPlaneGreen"
                         class="videoPlaneGreenClass"
                         color="#FFF"
                         width="1"
                         height="0.75"
                         position="0 0.6 -0.15"
                         material="side: double"
                         networked-video-source="useGreenScreen: true; greenThreshold: 0.04; streamName: video"
                         render-order-change="2000">
                </a-plane>

                <a-plane id="screenPlane"
                         color="#FFF"
                         width="0"
                         height="0"
                         position="0 0.6 -0.15"
                         material="side: double"
                         networked-video-source="streamName:screen">
                </a-plane>
            </a-entity>
        </template>
    </a-assets>

    <!-- Pawn -->
    <a-entity id="player"
              networked="template:#avatar-template;attachTemplateToLocal:false;"
              position="0 0.6 0"
              wasd-controls="fly: true; acceleration:5"
              show-position
              look-controls="pointerLockEnabled: false;">

        <a-sphere class="head"
                  visible="false"
                  random-color>
        </a-sphere>

        <a-entity
                active="true"
                camera="near: 0.1; far: 7000.0;"
                position="0 0.6 0">
        </a-entity>
    </a-entity>

</a-scene>


<script>

    AFRAME.registerComponent('show-position', {
        init: function () {
            this.positionShow = document.getElementById("positionShow");
            this.occupantsNumberShow = document.getElementById("occupantsNumberShow");
            /* this.occupantsShow = document.getElementById("occupantsShow");
             this.entitiesShow = document.getElementById("entitiesShow"); */
        },
        tick: function (time, timeDelta) {
            let p = this.el.getAttribute('position');
            this.positionShow.innerHTML = Math.round(p.x*100)/100 + ", " + Math.round(p.y*100)/100 + ", " + Math.round(p.z*100)/100;

            let occupants = window.easyrtc.getRoomOccupantsAsMap(window.NAF.room);
            if(occupants) {
                this.occupantsNumberShow.innerHTML = Object.keys(occupants).length;
            }
        }
    });

    const api_pattern_single = {
        ThresholdMin: 0.106,
        ThresholdMax: 0.13,
        red: 48, green: 146, blue: 89,
        w: 1, h: 0.75,
        x: 0, y:0, z:0,
        rx: 0, ry: 0, rz:0
    };

    const api_pattern_singleMin = {
        ThresholdMinLow: 0,
        ThresholdMaxLow: 0,
        redLow: 0,
        greenLow: 0,
        blueLow: 0,
        wLow: 0.1,
        hLow: 0.1,
        xLow:-100000,
        yLow:-100000,
        zLow:-100000,
        rxLow:-100,
        ryLow:-100,
        rzLow:-100
    };
    const api_pattern_singleMax = {
        ThresholdMinHigh: 0.4,
        ThresholdMaxHigh: 0.4,
        redHigh: 255,
        greenHigh: 255,
        blueHigh: 255,
        wHigh: 5,
        hHigh: 5,
        xHigh: 100000,
        yHigh: 100000,
        zHigh: 100000,
        rxHigh: 100,
        ryHigh: 100,
        rzHigh: 100
    };
    const api_pattern_singleStep = {
        ThresholdMinStep: 0.001,
        ThresholdMaxStep: 0.001,
        redStep: 1,
        greenStep: 1,
        blueStep: 1,
        wStep: 0.05,
        hStep: 0.05,
        xStep: 10,
        yStep: 10,
        zStep: 10,
        rxStep: 0.1,
        ryStep: 0.1,
        rzStep: 0.1
    };

    let btStatusControls = document.getElementById('obtainStatusAndSetSizeControls');
    btStatusControls.addEventListener('click', function() {

        let entities = window.NAF.connection.entities.entities;
        let panelsSizeControlsDiv = document.getElementById('panelsSizeControlsDiv');

        /* Clear Panels Size  Controls */
        panelsSizeControlsDiv.replaceChildren([]);

        /* DestroyGui */
        try {
            console.log("destroying");
            btStatusControls.gui.destroy();
        }
        catch (e) {
            console.log(e);
        }

        btStatusControls.gui = new dat.GUI( { width: 200 });

        let elementsDatGui = [];
        let videoUserGui = [];

        let nActor = 0;

        if(entities) {

            /* Canvas Size Controls */
            let panel = {};
            for (let e in entities){

                let h = window.NAF.connection.entities.entities[e].childNodes[1].getAttribute('height');
                if (h) {
                    nActor++;

                    /*  Thresholds Green */
                    videoUserGui[e] = btStatusControls.gui.addFolder(e);

                    /*  Panels  */
                    panel[e] = window.NAF.connection.entities.entities[e].childNodes[0].id === "videoPlaneGreen" ?
                        window.NAF.connection.entities.entities[e].childNodes[0] :
                        window.NAF.connection.entities.entities[e].childNodes[1] ;

                    elementsDatGui[e] = [];
                    for (let a in api_pattern_single) {

                        let L = a + "Low";
                        let H = a + "High";
                        let S = a + "Step";

                        elementsDatGui[e][a] = videoUserGui[e].add(api_pattern_single, a, api_pattern_singleMin[L], api_pattern_singleMax[H], api_pattern_singleStep[S]);

                        if (   a[0] === 'w'
                            || a[0] === 'h'
                            || a[0] === 'x'
                            || a[0] === 'y'
                            || a[0] === 'z'
                            || a.substring(0,2) === 'rx'
                            || a.substring(0,2) === 'ry'
                            || a.substring(0,2) === 'rz')
                        {

                            elementsDatGui[e][a].panelaki = panel[e];
                            elementsDatGui[e][a].domElement.pName = e;

                            switch (a[0]) {
                                case 'w':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[5].panelaki;
                                        p.setAttribute('width', api_pattern_single[this.property]);
                                    });
                                    break;
                                case 'h':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[6].panelaki;
                                        p.setAttribute('height', api_pattern_single[this.property]);
                                    });
                                    break;
                                case 'x':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[7].panelaki;
                                        p.getAttribute('position').x = api_pattern_single[this.property] / 10000;
                                    });
                                    break;
                                case 'y':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[8].panelaki;
                                        p.getAttribute('position').y = api_pattern_single[this.property] / 10000;
                                    });
                                    break;
                                case 'z':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[9].panelaki;
                                        p.getAttribute('position').z = api_pattern_single[this.property] / 10000;
                                    });
                                    break;


                            }

                            switch (a.substring(0,2)) {

                                case 'rx':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[10].panelaki;
                                        let xStr = api_pattern_single[this.property];
                                        let yStr = p.getAttribute('rotation').y;
                                        let zStr = p.getAttribute('rotation').z;
                                        p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                    });
                                    break;

                                case 'ry':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[11].panelaki;
                                        let xStr = p.getAttribute('rotation').x;
                                        let yStr = api_pattern_single[this.property];
                                        let zStr = p.getAttribute('rotation').z;
                                        p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                    });
                                    break;

                                case 'rz':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[12].panelaki;
                                        let xStr = p.getAttribute('rotation').x;
                                        let yStr = p.getAttribute('rotation').y;
                                        let zStr = api_pattern_single[this.property];
                                        p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                    });
                                    break;
                            }

                        } else {
                            elementsDatGui[e][a].onChange(function () {
                                let domAffected = document.getElementsByClassName("videoPlaneGreenClass")[elementsDatGui[e][a].nActor];
                                domAffected.setAttribute("networked-video-source", this.property, api_pattern_single[this.property]);
                            });
                        }
                        elementsDatGui[e][a].nActor = nActor-1;
                    }
                }
            }
        }
    });

    /* Define custom schema for syncing avatar color, set by random-color */
    NAF.schemas.add({
        template: '#avatar-template',
        components: [
            'position',
            'rotation'
        ]
    });

    /* Called by Networked-Aframe when connected to server */
    function onConnect () {
        console.log("onConnect", new Date());

        const screenBtnEle = document.getElementById('screen-btn-sendscreen');
        screenBtnEle.addEventListener('click', function() {
            navigator.mediaDevices.getDisplayMedia({
                preferCurrentTab: true,
                video: true,
                audio: true
            }).then((stream) => {
                NAF.connection.adapter.addLocalMediaStream(stream, "screen");
            });
        });
    }

    let record_button = document.getElementById('start-recording-btn');
    let video_preview = document.getElementById('video-preview');
    let stop_button = document.getElementById('stop-recording-btn');
    let download_button = document.getElementById('download-recording-btn');
    let upload_button = document.getElementById('upload-recording-btn');
    let capture_label = document.getElementById('captured-video-label');
    let recording = document.getElementById('recording');

    function startRecording(stream) {

        let recorder = new MediaRecorder(stream);
        let data = [];

        recorder.ondataavailable = event => data.push(event.data);
        recorder.start();

        let stopped = new Promise((resolve, reject) => {
            recorder.onstop = resolve;
            recorder.onerror = event => reject(event.name);
        });

        return Promise.all([
            stopped
        ]).then(() => data);
    }

    function stopRecording(stream) {
        stream.getTracks().forEach(track => track.stop());
        record_button.disabled = false;
        stop_button.disabled = true;
        download_button.disabled = false;
        upload_button.disabled = false;
    }

    let recordedBlob;

    record_button.addEventListener("click", function() {

        capture_label.innerHTML = '';

        navigator.mediaDevices.getDisplayMedia({
            preferCurrentTab: true,
            selfBrowserSurface: 'include',
            systemAudio: 'include',
            video: {
                cursor: 'never'
            },
            audio: true
        }).then(stream => {

            record_button.disabled = true;
            stop_button.disabled = false;

            video_preview.style.display = 'block';
            video_preview.srcObject = stream;
            download_button.href = stream;
            video_preview.captureStream = video_preview.captureStream || video_preview.mozCaptureStream;

            stream.getVideoTracks()[0].onended = function () {
                video_preview.style.display = 'none';
                stopRecording(video_preview.srcObject);
            };

            return new Promise( resolve => video_preview.onplaying = resolve );
        }).then(() => startRecording(video_preview.captureStream()))
            .then (recordedChunks => {

                recordedBlob = new Blob(recordedChunks, { type: "video/webm" });
                recording.src = URL.createObjectURL(recordedBlob);
                download_button.href = recording.src;
                download_button.download = "RecordedVideo.webm";

                upload_button.href = recording.src;
                capture_label.innerHTML = "Recorded " + formatBytes(recordedBlob.size) + " of " +
                    recordedBlob.type + " media.";

            });
    }, false);

    stop_button.addEventListener("click", function() {
        stopRecording(video_preview.srcObject);
    }, false);

    upload_button.addEventListener("click", function() {

        upload_button.disabled = true;

        const mv_url = document.getElementById('node-url-input').value;
        const mv_token = document.getElementById('node-token-input').value;
        const mv_project_id = document.getElementById('mv-project-id-input').value;

        const video_file = new File([recordedBlob], 'vrodos-'+ recordedBlob.size +'.webm', {
            type: recordedBlob.type,
        });

        let formData = new FormData();
        formData.append('file', video_file);

        fetch(mv_url + '/dam/assets?description=' + 'Recorded video from VROdos' + '&externalTool=VRodos', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${mv_token}`
            },
            body: formData
        }).then(function (response) {
            if (response.ok) {
                return response.json();
            } else {
                upload_button.disabled = false;
                alert("There has been a problem uploading your video to MediaVerse platform");
            }
        }).then(function (data) {

            fetch(mv_url + '/dam/project/' + mv_project_id, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${mv_token}`
                },
                body: JSON.stringify({
                    "projectOutput": [data.key]
                })
            }).then(function (response) {
                upload_button.disabled = false;
                if (response.ok) {
                    alert('The video has been successfully uploaded to MediaVerse!');
                } else {
                    alert("There has been a problem uploading your video to MediaVerse platform");
                    console.log(response.json());
                }
            })
        });
    });

    /* Scale down div when in compile preview */
    (function() {
        if (window.innerWidth < 400) {
            let actionsDiv = document.getElementById("actionsDiv");
            actionsDiv.style.transformOrigin="0px 200px";
            actionsDiv.style.scale = "0.3";
        }
    })();

    /* x button show clacket. key code 88 */
    document.addEventListener('keydown', function(e){
        if (e.keyCode === 88){
            document.getElementById('actionsDiv').style.display='block';

            if (document.getElementsByClassName('dg ac')[0]) {
                document.getElementsByClassName('dg ac')[0].style.display = 'block';
            }

            if (document.cancelFullScreen) {
                document.cancelFullScreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.webkitCancelFullScreen) {
                document.webkitCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }
    });

    /* Make full screen and hide controls */
    let director_controls = document.getElementById("toggle_controls");
    director_controls.onclick = function(){

        document.getElementById('actionsDiv').style.display='none';

        if (document.getElementsByClassName('dg ac')[0]) {
            document.getElementsByClassName('dg ac')[0].style.display = 'none';
        }

        let elem = document.body;

        if (elem.requestFullScreen) {
            elem.requestFullScreen();
        } else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
        } else if (elem.webkitRequestFullScreen) {
            elem.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
        } else if (elem.msRequestFullscreen) {
            elem.msRequestFullscreen();
        }
    };

    let formatBytes = (bytes, decimals = 2) => {
        if (!+bytes) return '0 Bytes'

        const k = 1024
        const dm = decimals < 0 ? 0 : decimals
        const sizes = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']

        const i = Math.floor(Math.log(bytes) / Math.log(k))

        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`
    };

</script>

<!-- This will change the glb materials -->
<script src="js/glb_material_changer.js"></script>

</body>
</html>

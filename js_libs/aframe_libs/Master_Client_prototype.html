<!DOCTYPE html>
<html lang="el">

<head>
    <meta charset="utf-8" />
    <title>Collaborative content creation</title>
    <meta name="description" content="Collaborative content creation" />

    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <script src="js/aframe/1.3.0/aframe.min.js"></script>
    <script src="js/socketio/2.3.0/socket.io.slim.js"></script>
    <script src="js/datgui/0.7.7/dat.gui.min.js"></script>

    <script src="../easyrtc/easyrtc.js"></script>
    <script src="../dist/networked-aframe.js"></script>

    <script src="js/a-water_alphamask_master.js"></script>
    <script src="js/sunsky/3.0.3/aframe-sun-sky.min.js"></script>
    <script src="js/randomizer/3.0.1/aframe-randomizer-components.min.js"></script>

    <script src="js/particles/aframe-particle-system-component.min.js"></script>
    <script src="js/spawn-in-circle.component.js"></script>

    <script src="js/highlight_img.js"></script>
    <script src="js/img_panel.js"></script>
    

    <script src="js/indicators_aframe.js"></script>
    <link rel="stylesheet" type="text/css" href="css/adv-screen.css" />


</head>

<body id="master-client-body">

    <script>
        AFRAME.registerComponent('clear-frustum-culling', {
            init: function () {
                let el = this.el;
                el.addEventListener("model-loaded", e => {
                    let mesh = el.getObject3D('mesh');
                    if (!mesh) { return; }
                    mesh.traverse(function (node) {
                        if (node.isMesh) {
                            node.frustumCulled = false;
                        }
                    });
                });
            }
        });

        AFRAME.registerComponent('scene-settings', {
            schema: { 
                color:{type: "string", default: "#ffffff"},
                pr_type:{type: "string", default: "default"},
                img_link:{type: "string", default: "no_link"},
             },
            init: function () {
                console.log(this.data.pr_type);
                
                let cam = document.querySelector("#cameraA");
                console.log(cam);
                if (this.data.pr_type == "virtualproduction_games" || this.data.pr_type == "archaeology_games")
                    cam.setAttribute("camera", "fov: 60");
                else{
                    cam.setAttribute("fov", "60");
                    cam.setAttribute("camera", "fov: 60"); //temp based on camera settings
                    
                }

                    

                let backgroundEl = document.querySelector('#aframe-scene-container');
                backgroundEl.setAttribute("background", "color", this.data.color);
            }
        });


        AFRAME.registerComponent('static-mask-me', {
            init: function () {
                let el = this.el;
                // el.addEventListener("model-loaded", e => {
                const maskMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: false,
                    colorWrite: false,
                });
                maskMaterial.needsUpdate = true;
                let mesh = el.getObject3D('mesh');
                if (!mesh) {
                    return;
                }
                mesh.traverse(node => {
                    if (!node.isMesh) {
                        return;
                    }
                    node.material = maskMaterial;
                    node.renderOrder = 999;
                });
                //  });
            },
            tick: null
        });

        AFRAME.registerComponent('render-order-change', {
            schema: {
                renderingOrderArg: { type: 'string', default: '2000' }
            },
            init: function () {
                let el = this.el;
                // el.addEventListener("model-loaded", e => {
                let mesh = el.getObject3D('mesh');
                if (!mesh) {
                    return;
                }
                mesh.traverse(node => {
                    if (!node.isMesh) {
                        return;
                    }
                    node.renderOrder = this.data.renderingOrderArg;

                });
                //  });
            },
            tick: null
        });
        AFRAME.registerComponent('video-controls', {
            schema: {
                id: { default: "default value" },
                orig_pos: {
                    'parse': function (val) {
                        return val.split(',');
                    }
                },
                orig_rot: {
                    'parse': function (val) {
                        return val.split(',');
                    }
                }
            },
            init: function () {


                let data = this.data;
                let video_id = "#video_" + data.id;
                let video = document.querySelector(video_id);
                let sBorder;
                let sDisplay;

                let video_display_id = "#video-display_" + data.id;
                let video_border_id = "#video-border_" + data.id;
                let vid_panel_id = "#vid-panel_" + data.id;
                //let vid_panel_id = "#vid-gui_" + data.id;

                let videoDisplay = document.querySelector(video_display_id);
                let videoPanel = document.querySelector(vid_panel_id);
                let videoBorder = document.querySelector(video_border_id);

                


                let fsEl = document.querySelector("#ent_fs_" + data.id);
                let plEl = document.querySelector("#ent_pl_" + data.id);
                let exEl = document.querySelector("#ent_ex_" + data.id);
                let titEl = document.querySelector("#ent_tit_" + data.id);
                let backgroundEl = document.querySelector('#aframe-scene-container');
                
                let playerEl = document.querySelector('#player');
                let rightHand = document.querySelector('#oculusRight');
                //videoMesh.material.wireframe = true;
                let bcgCol = backgroundEl.getAttribute("scene-settings");
                let cam = document.querySelector("#cameraA");
                let camRig = document.querySelector("#camera-rig");

                let media_panel = document.getElementById("mediaPanel");
                let recording_controls = document.getElementById("upload-recording-btn");

                cam.add(videoPanel);

                


                const entCollection = document.getElementsByClassName("hideable");


                video.addEventListener("ended", (e) => {
                    playUpd(plEl);
                    
                })

                function restoreVidPos(border, disp, panel) {
                    let offsetX = 20;
                    

                    var curr_rot = border.getAttribute('rotation');

                    //console.log(curr_rot);
                    border.object3D.rotation.set(
                        THREE.MathUtils.degToRad(0),
                        THREE.MathUtils.degToRad(0),
                        THREE.MathUtils.degToRad(0)
                    );
                    
                    console.log(border);

                    console.log(border.getAttribute("original-scale"));

                    border.object3D.rotation.set(
                        THREE.MathUtils.degToRad(data.orig_rot[0] * (180 / Math.PI)),
                        THREE.MathUtils.degToRad(data.orig_rot[1] * (180 / Math.PI)),
                        THREE.MathUtils.degToRad(data.orig_rot[2] * (180 / Math.PI))
                    );
                    


                }





                backgroundEl.addEventListener('loaded', function () {


                    let rotateB = videoBorder.getAttribute("rotation");
       

                    let videoMesh = videoDisplay.getObject3D("mesh");
                    let borderMesh = videoBorder.getObject3D("mesh");


                    let bbox = new THREE.Box3().setFromObject(videoDisplay.object3D);


                    const vector = new THREE.Vector3();
                    var centered_values = bbox.getCenter(vector);

                    var box3 = new THREE.Box3();
                    var size = new THREE.Vector3(); // create once and reuse

                    let screen_img_src = "#video_fullScreen_" + this.data;
                    let borderCords = videoBorder.getAttribute("position");
            
                    restoreVidPos(videoBorder, videoDisplay, videoPanel);



                });





                let visCollection = [];
                let origPosBorder;
                let origPosDisplay;
                let height = 15;
                let width = 20;
                let dist = 25;
                console.log(videoPanel);

                //fsEl.object3D.position.set(0, 0, 0);

                function addToCam(obj, non_visible, trans, opac) {
                   
                    if (non_visible) {
                        obj.object3D.renderOrder = 9999999;
                        //clipIntersection
                        obj.components.material.material.depthTest = false;
                        obj.components.material.material.transparent = trans;
                        obj.components.material.material.opacity = opac;

                        obj.setAttribute("visible", "true");
                        obj.setAttribute("scale", "1 1 1");
                        //obj.setAttribute("position", pos);

                     
               

                

                    }
                    else {
                        obj.setAttribute("visible", "false");
                        obj.setAttribute("scale", "0.001 0.001 0.001");

                    }

                };

                function addToCamText(obj, non_visible, trans, opac) {
                    if (non_visible) {
                        obj.object3D.renderOrder = 9999999;
                        //clipIntersection
                        obj.components.text.material.depthTest = false;
                        obj.components.text.material.transparent = trans;
                        obj.components.text.material.opacity = opac;

                        obj.setAttribute("visible", "true");
                        obj.setAttribute("scale", "1 1 1");
                        //obj.setAttribute("position", pos);
                    }
                    else {
                        obj.setAttribute("visible", "false");
                        obj.setAttribute("scale", "0.001 0.001 0.001");

                    }

                };
                function playUpd(obj) {
                    if (video.paused) {
                        obj.setAttribute("src", "#video_pl_" + data.id);

                    }
                    else {
                        obj.setAttribute("src", "#video_pas_" + data.id);
                    }
                    obj.setAttribute("material", "depthTest: false");
                    obj.setAttribute("material", "transparent: true");
                    obj.setAttribute("material", "opacity: 1");

                };

                plEl.addEventListener("mouseup", function (event) {
                    if (video.paused) {
                        video.play();

                    }
                    else {
                        video.pause();

                    }

                    playUpd(plEl);

                });

                exEl.addEventListener("mouseup", function (event) {
                    addToCam(videoPanel, false, true, 0.3);
                    if (video.paused) {
                        console.log("Video Paused. Exiting...")

                    }
                    else {
                        video.pause();

                    }
                    videoDisplay.classList.remove("non-clickable");
                    videoPanel.classList.remove("non-clickable");
                    backgroundEl.setAttribute("raycaster","objects: .raycastable");
                    if(rightHand)
                        rightHand.setAttribute("raycaster","objects: .raycastable");
                });



                fsEl.addEventListener("mouseup", function (event) {
                    if (camRig)                                          //TODO change based on project type
                        camRig.setAttribute("position", "0 0 0");
                    else{
                        cam.setAttribute("position", "0 0 0");
                        media_panel.setAttribute( "style", 'visibility: hidden;' );
                        recording_controls.setAttribute('style', 'visibility: hidden;');
                    }
                                                                                   

                    cam.setAttribute("camera", "fov", 2 * Math.atan((height / 2) / (dist)) * (180 / Math.PI));
                    backgroundEl.setAttribute("background", "color", "black");
                    backgroundEl.setAttribute("overlay", "");
                    

                    cam.add(videoBorder);
                    cam.add(videoDisplay);
                    videoBorder.setAttribute("height", "15");
                    videoBorder.setAttribute("width", "20");
                    videoDisplay.setAttribute("height", "15");
                    videoDisplay.setAttribute("width", "20");
                    videoBorder.setAttribute("position", "0 0 -25");
                    videoDisplay.setAttribute("position", "0 0 -25");
                    videoBorder.setAttribute("scale", "1 1 1");
                    videoDisplay.setAttribute("scale", "1 1 1");
                    videoBorder.setAttribute("rotation", "0 0 0");
                    videoDisplay.setAttribute("rotation", "0 0 0");
                    console.log(videoBorder);

                    if (video.paused) {
                        video.play();

                    }
                    for (let i = 0; i < entCollection.length; i++) {
                        
                        
                        
                        console.log(videoDisplay);
                        console.log(entCollection[i]);
                        if (entCollection[i] !=videoDisplay){
                            entCollection[i].setAttribute("visible", "false");
                            console.log(entCollection[i].getAttribute("visible"));
                            entCollection[i].setAttribute("scale", "0.00001 0.00001 0.00001");
                            
                            
                        }
                           
                        visCollection.push(i);


                       

                    }
                    if (playerEl.getAttribute("wasd-controls")){
                        playerEl.setAttribute("wasd-controls", "fly: false; acceleration:0");
                    }else
                        cam.setAttribute("wasd-controls-enabled", "false");
                  

                    playUpd(plEl);




                });



                function restoreVid(){
                    console.log("playing");
                    //video.pause();
                    if (camRig)
                        camRig.setAttribute("position", "0 0.6 0");
                    else{
                        cam.setAttribute("position", "0 0.6 0");
                        media_panel.setAttribute( "style", 'visibility: visible;' );        //TODO change based on project type
                        recording_controls.setAttribute('style', 'visibility: visible;');
                    }

                    cam.setAttribute("camera", "fov", 60);
                    //console.log(backgroundEl);
                    let bcgCol = backgroundEl.getAttribute("scene-settings").color;
                    console.log(bcgCol);
                    backgroundEl.setAttribute("background", "color", bcgCol);
                    //console.log(visCollection);
                    //restoreVidPos(videoBorder, videoDisplay, videoPanel);
                    for (let i = 0; i < visCollection.length; i++) {
                        entCollection[visCollection[i]].setAttribute("visible", "true");

                        console.log(entCollection[visCollection[i]].getAttribute("original-scale"));

                        entCollection[visCollection[i]].setAttribute("scale", entCollection[visCollection[i]].getAttribute("original-scale"));    //TODO: incorporate asset manager solution to avoid this
                        //entCollection[visCollection[i]].classList.add("non-clickable");

                        //videoDisplay.setAttribute("position", origPosDisplay);

                    }
                   
                    if (playerEl.getAttribute("wasd-controls")){
                        playerEl.setAttribute("wasd-controls", "fly: false; acceleration:20");
                    }else
                        cam.setAttribute("wasd-controls-enabled", "true");
                    //playerEl.setAttribute("look-controls", "enabled: true");
                    backgroundEl.add(videoBorder);
                    backgroundEl.add(videoDisplay);
                    let p_x = data.orig_pos[0] + ' ' + data.orig_pos[1] + ' ' + data.orig_pos[2];
                    let r_x = data.orig_rot[0] * (180 / Math.PI) + ' ' + data.orig_rot[1] * (180 / Math.PI) + ' ' + data.orig_rot[2] * (180 / Math.PI);

                    
                    videoBorder.setAttribute("height", "3");
                    videoBorder.setAttribute("width", "4");

                    videoDisplay.setAttribute("height", "3");
                    videoDisplay.setAttribute("width", "4");
                    videoBorder.setAttribute("position", p_x);
                    videoDisplay.setAttribute("position", p_x);
                    videoBorder.setAttribute("scale", videoBorder.getAttribute("original-scale")); 
                    videoDisplay.setAttribute("scale", videoBorder.getAttribute("original-scale")); 

                    videoBorder.setAttribute("rotation", r_x);
                    videoDisplay.setAttribute("rotation", r_x);
                    //videoDisplay.setAttribute("position", "%s %s %s", p_x, p_y, p_z);
                    console.log(videoBorder.getAttribute("rotation"));
                    console.log(data.orig_rot[0] + " " + data.orig_rot[1] + " " + data.orig_rot[2]);
                    visCollection = [];
                }
                if (video.getAttribute("src")){
                    videoBorder.addEventListener("mouseup", function (event) {
                        addToCam(videoPanel, true, true, 1);
                        addToCam(fsEl, true, true, 1);
                        addToCam(plEl, true, true, 1);
                        addToCam(exEl, true, true, 1);
                        addToCamText(titEl, true, true, 1);
                        //console.log(titEl.components);
                        videoDisplay.classList.add("non-clickable");
                        videoPanel.classList.add("non-clickable");
                        backgroundEl.setAttribute("raycaster","objects: .non-clickable");
                        if(rightHand)
                            rightHand.setAttribute("raycaster","objects: .non-clickable");

                        console.log(videoPanel.getAttribute("visible"));
                        playUpd(plEl);

                        
                    
                    
                        if (video.paused) {
                            console.log("border clicked");
                        }
                        else if (video.play){
                            //addToCam(videoPanel, "35 5 -25", false);
                            restoreVid();
                            //playUpd(plEl);

                        }
                        if (video.ended){
                            restoreVid();
                        }
                    });
                }

            }

        });
        AFRAME.registerComponent('door-listener', {
            schema: { type: "string", default: "default value" },
            init: function () {
                this.el.setAttribute("link", "on: click; href: " + this.data);
            }
        });

        AFRAME.registerComponent('link-listener', {
            schema: { type: "string"},
            init: function () {

                if (this.data){
                    this.el.addEventListener("click", e => {
                        if (!this.data.match(/^https?:\/\//i)) {
                            this.data = '//' + this.data;
                        }
                        window.open(this.data);
                    });
                }
            }
        });

        AFRAME.registerComponent("overlay", {
            dependencies: ['material'],
            init: function () {
                this.el.sceneEl.renderer.sortObjects = true;
                this.el.object3D.renderOrder = 100;
                this.el.components.material.material.depthTest = false;
            }
        })

        AFRAME.registerComponent('image-display', {
            schema: {
                id_img: { default: "default value" },
                main_img: { default: "default value" },
                esc_img: { default: "default value" }
            },
            init: function () {



                let click_event = this.el.addEventListener("click", e => {
                    this.el.emit("img_open");
                    let cam = document.getElementById("player");
                    //this.el.emit("event1");
                    /*
    
                    var entity_main = document.createElement('a-plane');
                    var title_main = document.createElement('a-text');
    
                    var desc_main = document.createElement('a-text');
                    */

                    let entitycheck = document.getElementById(this.data.id_img);
                    if (!entitycheck) {
                    

                        var entity_esc = document.createElement('a-plane');

                        entity_esc.setAttribute("src", '#' + this.data.esc_img);

                        // Set the position of the box to the click intersection.
                        entity_esc.setAttribute("height", "1");
                        entity_esc.setAttribute("width", "1");
                        entity_esc.setAttribute("position", "3  7 -9");
                        entity_esc.setAttribute("material", "shader: flat");
                        entity_esc.setAttribute("overlay", "");
                        entity_esc.addEventListener("click", e => { cam.removeChild(entity_main); cam.removeChild(entity_esc); cam.removeChild(title_main); cam.removeChild(desc_main); });

                        // Append the box element to the scene.
                        cam.appendChild(entity_esc);
                    }
                });

                this.el.addEventListener("img_open", e => {
                 
                    console.log("Clicked");
                    removeEventListener('click', click_event, false);
                    
                });
                this.el.addEventListener("animationcomplete", e => {
                  
                    console.log("Animation completed");
                  
                });
            }
        });

        AFRAME.registerComponent('left-thumbstick', {
            init: function () {
                var hand = this.el;
                var cameraRig = document.querySelector('#camera-rig');

                hand.addEventListener('thumbstickmoved', function (event) {
                    var movementVector = new THREE.Vector3(event.detail.x, 0, event.detail.y);
                    cameraRig.object3D.position.add(movementVector.multiplyScalar(cameraRig.getAttribute('movement-controls').data.speed));
                });
            }
        });

        //document.querySelector('#left-hand').setAttribute('left-thumbstick', '');

        AFRAME.registerComponent('show-position', {
            init: function () {
                this.positionShow = document.getElementById("positionShow");
                this.occupantsNumberShow = document.getElementById("occupantsNumberShow");
            },
            tick: function (time, timeDelta) {
                let p = this.el.getAttribute('position');
                this.positionShow.innerHTML = Math.round(p.x * 100) / 100 + ", " + Math.round(p.y * 100) / 100 + ", " + Math.round(p.z * 100) / 100;

                let occupants = window.easyrtc.getRoomOccupantsAsMap(window.NAF.room);
                if (occupants) {
                    this.occupantsNumberShow.innerHTML = Object.keys(occupants).length;
                }
            }
        });

        AFRAME.registerComponent('custom-movement', {
        init: function () {
            const cameraEl = document.querySelector('a-camera');
            const cameraRig = this.el;

            this.el.addEventListener('thumbstickmoved', (event) => {
            const thumbstickX = event.detail.x;
            const thumbstickY = event.detail.y;

            // Get camera rotation
            const rotation = cameraEl.getAttribute('rotation');
            const angleY = THREE.Math.degToRad(rotation.y);
            //const angleX = THREE.Math.degToRad(rotation.x);

            // Calculate movement direction based on camera rotation
            const direction = new THREE.Vector3(-Math.sin(angleY), 0, -Math.cos(angleY));

            // Apply movement to the camera rig's position
            const movementSpeed = 0.1;
            cameraRig.object3D.translateX(-direction.x * thumbstickY * movementSpeed - direction.z * thumbstickX * movementSpeed);
            cameraRig.object3D.translateZ(-direction.z * thumbstickY * movementSpeed + direction.x * thumbstickX * movementSpeed);
            

            console.log('Camera rotation:', rotation.x, rotation.y, rotation.z);
            });
        }
        });


    </script>

    <div id="mediaPanel">
        <div class="wrapperVideoElement" style="visibility: hidden">
            <video id="video-preview" width="300" height="200" autoplay muted></video>
            <video id="recording" hidden></video>
        </div>

        <div class="actionsDirector" name="actionsDiv" id="actionsDiv">
            <div id="toggle_controls">Close <span style="color: white">("x" button to show again)</span></div>
            <div id="directorline" style=""></div>


            <div class="wrapperControlElement">
                <label for="roomNameShow" title="Name of Room">&#127917;</label>
                <span id="roomNameShow">roomname</span>
            </div>

            <div class="wrapperControlElement">
                <label for="occupantsNumberShow" title="Number of actors">&#128101;</label>
                <span id="occupantsNumberShow"></span>
            </div>

            <div class="wrapperControlElement">
                <button id="obtainStatusAndSetSizeControls" class="buttonMultiplaying"
                    title="Obtain status and control green screens">
                    &#128260; &#9989;
                </button>
            </div>

            <div class="wrapperControlElement" >
                <button id="screen-btn-sendscreen" class="buttonMultiplaying" title="Send scene stream back to actors">
                    &#127909; &#9654; &#128101;
                </button>
            </div>

            <div class="wrapperControlLineElement">
                <button id="start-recording-btn" class="buttonStartRecord" title="Start capturing video">
                    ⚪️
                </button>

                <button id="stop-recording-btn" class="buttonStopRecord" title="Save capture" disabled>
                    ◼️
                </button>

                <a id="download-recording-btn" class="buttonDownloadRecording" title="Download video" disabled>
                    💾️️
                </a>

                <button id="upload-recording-btn" class="buttonUploadRecording" style="visibility: hidden;"
                    title="Upload Recording to MediaVerse" disabled>
                    ⬆️️️
                </button>
            </div>
            <div class="wrapperControlElement">
                <span id="captured-video-label"></span>
            </div>
            <div class="wrapperControlElement">
                <label for="positionShow" title="Camera Position">&#127909;</label>
                <span id="positionShow"></span>
            </div>

            <div id="panelsSizeControlsDiv"></div>
            <input id="node-url-input" hidden disabled />
            <input id="node-token-input" hidden disabled />
            <input id="mv-project-id-input" hidden disabled />
        </div>
    </div>



    <a-scene oculus-go-controls-enabled id="aframe-scene-container"  fog="type: linear; color: #AAB; far: 230; near: 0"
        renderer="antialias: true; sortObjects: true; toneMapping: ACESFilmic" background="color: white"
        vr-mode-ui="enabled: true" networked-scene="
        room: roomname;
        debug: true;
        audio: true;
        adapter: easyrtc;
       " environment cursor="rayOrigin: mouse; fuse: false" raycaster="objects: .raycastable">

       


        <a-assets>
            <!-- Avatar Template -->
            <template id="avatar-template">
                <a-entity class="avatar"
                networked-audio-source>

                    <a-plane id="videoPlaneGreen"
                            class="videoPlaneGreenClass"
                            color="#FFF"
                            width="1"
                            height="0.75"
                            position="0 0.6 -0.15"
                            material="side: double"
                            networked-video-source="useGreenScreen: true; greenThreshold: 0.04; streamName: video"
                            render-order-change="2000">
                    </a-plane>

                    <a-plane id="screenPlane"
                            color="#FFF"
                            width="0"
                            height="0"
                            position="0 0.6 -0.15"
                            material="side: double"
                            networked-video-source="streamName:screen">
                    </a-plane>
                </a-entity>
            </template>

            <template id="avatar-template-expo">
                <a-entity class="avatar">
                    <a-entity position="0 -0.5 0" class="model" gltf-model="#avatar_glb"></a-entity>
                </a-entity>
            </template>

            <a-mixin id="vid_panel" geometry="primitive: plane; width: 0.5783552; height: 0.8192"
                material="color: black; shader: flat"></a-mixin>
            <a-mixin id="frame" geometry="primitive: plane; width: 0.5783552; height: 0.8192"
                material="color: white; shader: flat"
                animation__scale="property: scale; to: 1.2 1.2 1.2; dur: 200;  startEvents: tmp1"
                animation__scale_reverse="property: scale; to: 1 1 1; dur: 200; startEvents: tmp2"></a-mixin>
            <a-mixin id="poster" geometry="primitive: plane; width: 0.544768; height: 0.786432"
                material="color: white; shader: flat" material="shader: flat" position="0 0 0.005"></a-mixin>
            <a-mixin id="poiImage" geometry="primitive: plane; width: 1.5; height: 0.81"
                material="shader: flat; transparent: true" position="0 0.495 0.002"></a-mixin>
            <a-mixin id="poiImageFull" geometry="primitive: plane; width: 1.5; height: 1.5"
                material="shader: flat; transparent: true" position="0 0 0.002"></a-mixin>
            <a-mixin id="poiEsc" geometry="primitive: plane; width: 0.1; height: 0.2"
                material="shader: flat; transparent: true" position="1 0.8 0.002"></a-mixin>
        </a-assets>
    

        <!-- Pawn -->
        <a-entity id="player">
        </a-entity>

         


    </a-scene>


    <script>

        const api_pattern_single = {
            ThresholdMin: 0.106,
            ThresholdMax: 0.13,
            red: 48, green: 146, blue: 89,
            w: 1, h: 0.75,
            x: 0, y: 0, z: 0,
            rx: 0, ry: 0, rz: 0
        };

        const api_pattern_singleMin = {
            ThresholdMinLow: 0,
            ThresholdMaxLow: 0,
            redLow: 0,
            greenLow: 0,
            blueLow: 0,
            wLow: 0.1,
            hLow: 0.1,
            xLow: -100000,
            yLow: -100000,
            zLow: -100000,
            rxLow: -100,
            ryLow: -100,
            rzLow: -100
        };
        const api_pattern_singleMax = {
            ThresholdMinHigh: 0.4,
            ThresholdMaxHigh: 0.4,
            redHigh: 255,
            greenHigh: 255,
            blueHigh: 255,
            wHigh: 5,
            hHigh: 5,
            xHigh: 100000,
            yHigh: 100000,
            zHigh: 100000,
            rxHigh: 100,
            ryHigh: 100,
            rzHigh: 100
        };
        const api_pattern_singleStep = {
            ThresholdMinStep: 0.001,
            ThresholdMaxStep: 0.001,
            redStep: 1,
            greenStep: 1,
            blueStep: 1,
            wStep: 0.05,
            hStep: 0.05,
            xStep: 10,
            yStep: 10,
            zStep: 10,
            rxStep: 0.1,
            ryStep: 0.1,
            rzStep: 0.1
        };

        let btStatusControls = document.getElementById('obtainStatusAndSetSizeControls');
        btStatusControls.addEventListener('click', function () {

            let entities = window.NAF.connection.entities.entities;
            let panelsSizeControlsDiv = document.getElementById('panelsSizeControlsDiv');

            /* Clear Panels Size  Controls */
            panelsSizeControlsDiv.replaceChildren([]);

            /* DestroyGui */
            try {
                console.log("destroying");
                if (btStatusControls.gui) {
                    btStatusControls.gui.destroy();
                }
            }
            catch (e) {
                console.log(e);
            }

            btStatusControls.gui = new dat.GUI({ width: 200 });

            let elementsDatGui = [];
            let videoUserGui = [];

            let nActor = 0;

            if (entities) {

                /* Canvas Size Controls */
                let panel = {};
                for (let e in entities) {

                    let h = window.NAF.connection.entities.entities[e].childNodes[1].getAttribute('height');
                    if (h) {
                        nActor++;

                        /*  Thresholds Green */
                        videoUserGui[e] = btStatusControls.gui.addFolder(e);

                        /*  Panels  */
                        panel[e] = window.NAF.connection.entities.entities[e].childNodes[0].id === "videoPlaneGreen" ?
                            window.NAF.connection.entities.entities[e].childNodes[0] :
                            window.NAF.connection.entities.entities[e].childNodes[1];

                        elementsDatGui[e] = [];
                        for (let a in api_pattern_single) {

                            let L = a + "Low";
                            let H = a + "High";
                            let S = a + "Step";

                            elementsDatGui[e][a] = videoUserGui[e].add(api_pattern_single, a, api_pattern_singleMin[L], api_pattern_singleMax[H], api_pattern_singleStep[S]);

                            if (a[0] === 'w'
                                || a[0] === 'h'
                                || a[0] === 'x'
                                || a[0] === 'y'
                                || a[0] === 'z'
                                || a.substring(0, 2) === 'rx'
                                || a.substring(0, 2) === 'ry'
                                || a.substring(0, 2) === 'rz') {

                                elementsDatGui[e][a].panelaki = panel[e];
                                elementsDatGui[e][a].domElement.pName = e;

                                switch (a[0]) {
                                    case 'w':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[5].panelaki;
                                            p.setAttribute('width', api_pattern_single[this.property]);
                                        });
                                        break;
                                    case 'h':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[6].panelaki;
                                            p.setAttribute('height', api_pattern_single[this.property]);
                                        });
                                        break;
                                    case 'x':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[7].panelaki;
                                            p.getAttribute('position').x = api_pattern_single[this.property] / 10000;
                                        });
                                        break;
                                    case 'y':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[8].panelaki;
                                            p.getAttribute('position').y = api_pattern_single[this.property] / 10000;
                                        });
                                        break;
                                    case 'z':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[9].panelaki;
                                            p.getAttribute('position').z = api_pattern_single[this.property] / 10000;
                                        });
                                        break;


                                }

                                switch (a.substring(0, 2)) {

                                    case 'rx':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[10].panelaki;
                                            let xStr = api_pattern_single[this.property];
                                            let yStr = p.getAttribute('rotation').y;
                                            let zStr = p.getAttribute('rotation').z;
                                            p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                        });
                                        break;

                                    case 'ry':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[11].panelaki;
                                            let xStr = p.getAttribute('rotation').x;
                                            let yStr = api_pattern_single[this.property];
                                            let zStr = p.getAttribute('rotation').z;
                                            p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                        });
                                        break;

                                    case 'rz':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[12].panelaki;
                                            let xStr = p.getAttribute('rotation').x;
                                            let yStr = p.getAttribute('rotation').y;
                                            let zStr = api_pattern_single[this.property];
                                            p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                        });
                                        break;
                                }

                            } else {
                                elementsDatGui[e][a].onChange(function () {
                                    let domAffected = document.getElementsByClassName("videoPlaneGreenClass")[elementsDatGui[e][a].nActor];
                                    domAffected.setAttribute("networked-video-source", this.property, api_pattern_single[this.property]);
                                });
                            }
                            elementsDatGui[e][a].nActor = nActor - 1;
                        }
                    }
                }
            }
        });

        /* Define custom schema for syncing avatar color, set by random-color */
        NAF.schemas.add({
            template: '#avatar-template',
            components: [
                'position',
                'rotation'
            ],
        });

        NAF.schemas.add({
            template: '#avatar-template-expo',
            components: [
                'position',
                'rotation',
                {
                    selector: '.model',
                    component: 'gltf-model'
                }
            ]
        });

        /* Called by Networked-Aframe when connected to server */
        function onConnect() {
            console.log("onConnect", new Date());

            const screenBtnEle = document.getElementById('screen-btn-sendscreen');
            screenBtnEle.addEventListener('click', function () {
                navigator.mediaDevices.getDisplayMedia({
                    preferCurrentTab: true,
                    selfBrowserSurface: 'include',
                    audio: true
                }).then((stream) => {
                    NAF.connection.adapter.addLocalMediaStream(stream, "screen");
                });
            });
        }

        let record_button = document.getElementById('start-recording-btn');
        let video_preview = document.getElementById('video-preview');
        let stop_button = document.getElementById('stop-recording-btn');
        let download_button = document.getElementById('download-recording-btn');
        let upload_button = document.getElementById('upload-recording-btn');
        let capture_label = document.getElementById('captured-video-label');
        let recording = document.getElementById('recording');

        function startRecording(stream) {

            let recorder = new MediaRecorder(stream);
            let data = [];

            recorder.ondataavailable = event => data.push(event.data);
            recorder.start();

            let stopped = new Promise((resolve, reject) => {
                recorder.onstop = resolve;
                recorder.onerror = event => reject(event.name);
            });

            return Promise.all([
                stopped
            ]).then(() => data);
        }

        function stopRecording(stream) {
            stream.getTracks().forEach(track => track.stop());
            record_button.disabled = false;
            stop_button.disabled = true;
            download_button.disabled = false;
            upload_button.disabled = false;
        }

        let recordedBlob;

        record_button.addEventListener("click", function () {

            capture_label.innerHTML = '';

            navigator.mediaDevices.getDisplayMedia({
                preferCurrentTab: true,
                selfBrowserSurface: 'include',
                systemAudio: 'include',
                video: {
                    cursor: 'never'
                },
                audio: true
            }).then(stream => {

                record_button.disabled = true;
                stop_button.disabled = false;

                video_preview.style.display = 'block';
                video_preview.srcObject = stream;
                download_button.href = stream;
                video_preview.captureStream = video_preview.captureStream || video_preview.mozCaptureStream;

                stream.getVideoTracks()[0].onended = function () {
                    video_preview.style.display = 'none';
                    stopRecording(video_preview.srcObject);
                };

                return new Promise(resolve => video_preview.onplaying = resolve);
            }).then(() => startRecording(video_preview.captureStream()))
                .then(recordedChunks => {

                    recordedBlob = new Blob(recordedChunks, { type: "video/webm" });
                    recording.src = URL.createObjectURL(recordedBlob);
                    download_button.href = recording.src;
                    download_button.download = "RecordedVideo.webm";

                    upload_button.href = recording.src;
                    capture_label.innerHTML = "Recorded " + formatBytes(recordedBlob.size) + " of " +
                        recordedBlob.type + " media.";

                });
        }, false);

        stop_button.addEventListener("click", function () {
            stopRecording(video_preview.srcObject);
        }, false);

        upload_button.addEventListener("click", function () {

            upload_button.disabled = true;

            const mv_url = document.getElementById('node-url-input').value;
            const mv_token = document.getElementById('node-token-input').value;
            const mv_project_id = document.getElementById('mv-project-id-input').value;

            const video_file = new File([recordedBlob], 'vrodos-' + recordedBlob.size + '.webm', {
                type: recordedBlob.type,
            });

            let formData = new FormData();
            formData.append('file', video_file);

            fetch(mv_url + '/dam/assets?description=' + 'Recorded video from VROdos' + '&externalTool=VRodos', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${mv_token}`
                },
                body: formData
            }).then(function (response) {
                if (response.ok) {
                    return response.json();
                } else {
                    upload_button.disabled = false;
                    alert("There has been a problem uploading your video to MediaVerse platform");
                }
            }).then(function (data) {

                fetch(mv_url + '/dam/project/' + mv_project_id, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${mv_token}`
                    },
                    body: JSON.stringify({
                        "projectOutput": [data.key]
                    })
                }).then(function (response) {
                    upload_button.disabled = false;
                    if (response.ok) {
                        alert('The video has been successfully uploaded to MediaVerse!');
                    } else {
                        alert("There has been a problem uploading your video to MediaVerse platform");
                        console.log(response.json());
                    }
                })
            });
        });

        /* Scale down div when in compile preview */
        (function () {
            if (window.innerWidth < 400) {
                let actionsDiv = document.getElementById("actionsDiv");
                actionsDiv.style.transformOrigin = "0px 200px";
                actionsDiv.style.scale = "0.3";
            }
        })();

        /* x button show clacket. key code 88 */
        document.addEventListener('keydown', function (e) {
            if (e.keyCode === 88) {
                document.getElementById('actionsDiv').style.display = 'block';

                if (document.getElementsByClassName('dg ac')[0]) {
                    document.getElementsByClassName('dg ac')[0].style.display = 'block';
                }

                if (document.cancelFullScreen) {
                    document.cancelFullScreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitCancelFullScreen) {
                    document.webkitCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        });

        /* Make full screen and hide controls */
        let director_controls = document.getElementById("toggle_controls");
        director_controls.onclick = function () {

            document.getElementById('actionsDiv').style.display = 'none';

            if (document.getElementsByClassName('dg ac')[0]) {
                document.getElementsByClassName('dg ac')[0].style.display = 'none';
            }

            let elem = document.body;

            if (elem.requestFullScreen) {
                elem.requestFullScreen();
            } else if (elem.mozRequestFullScreen) {
                elem.mozRequestFullScreen();
            } else if (elem.webkitRequestFullScreen) {
                elem.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            }
        };

        let formatBytes = (bytes, decimals = 2) => {
            if (!+bytes) return '0 Bytes'

            const k = 1024
            const dm = decimals < 0 ? 0 : decimals
            const sizes = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']

            const i = Math.floor(Math.log(bytes) / Math.log(k))

            return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`
        };

    </script>

    <!-- This will change the glb materials -->
    <script src="js/glb_material_changer.js"></script>

</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-63HJZ7CJRR"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-63HJZ7CJRR');
    </script>

    <meta charset="utf-8" />
    <title>Collaborative content creation</title>
    <meta name="description" content="Collaborative content creation" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.min.js"></script>
    <script src="js/datgui/0.7.9/dat.gui.min.js"></script>

    <script src="../easyrtc/easyrtc.js"></script>
    <script src="../dist/networked-aframe.js"></script>

    <!--<script src="js/a-water_alphamask_master.js"></script>-->

    <script src="js/highlight_img.js"></script>

    <script src="js/components/poi-image_component.js"></script>
    <script src="js/components/poi-help_component.js"></script>
    <script src="js/components/indicator_component.js"></script>
    <script src="js/components/poi-link_component.js"></script>
    <script src="js/components/door_component.js"></script>
    <script src="js/components/video_component.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/aframe-extras@7.6.0/dist/aframe-extras.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/aframe-environment-component@1.5.0/dist/aframe-environment-component.min.js"></script>

    <!-- ReadyPlayerMe avatars work natively with A-Frame's gltf-model component -->
    <!-- No additional library needed for GLB avatar loading -->

    <script src="js/indicators_aframe.js"></script>
    <script src="dist/material-components-web.min.js"></script>

    <link rel="stylesheet" type="text/css" href="css/adv-screen.css" />
    <link rel="stylesheet" type="text/css" href="dist/material-components-web.min.css" />
    <link rel="stylesheet" type="text/css" href="css/material-icons/material-icons.css" />



    <!---- Blink Controls ---->
    <script src="https://cdn.jsdelivr.net/npm/aframe-blink-controls/dist/aframe-blink-controls.min.js"></script>

    <script>

        const vectorRequiresUpdateRotation = epsilon => {
            return () => {
                let prev = null;

                return curr => {
                    if (prev === null) {
                        prev = new THREE.Vector3(curr.x, curr.y, curr.z);
                        return true;
                    } else if (!NAF.utils.almostEqualVec3(prev, curr, epsilon)) {
                        curr.x = 0;

                        prev.copy(curr);
                        return true;
                    }

                    return false;
                };
            };
        };
        // Global variable to switch between interfaces for interaction modes.
        let browsingModeVR = false;

        /* PLAYER AVATARS (COLOR AND NAME) */
        // Temporary workaround for template declaration; see issue 167
        NAF.schemas.getComponentsOriginal = NAF.schemas.getComponents;
        NAF.schemas.getComponents = (template) => {
            if (!NAF.schemas.hasTemplate('#avatar-template-expo')) {
                NAF.schemas.add({
                    template: '#avatar-template-expo',
                    components: [
                        'position',
                        'player-info',
                        'avatar-movement-info',
                        {
                            selector: '.rpm_avatar', // the model entity has a .model class
                            component: 'gltf-model', // we want the gltf-model component to sync between clients
                        },
                        {
                            component: 'rotation',
                            requiresNetworkUpdate: vectorRequiresUpdateRotation(0.5)
                        }

                    ]
                });
            }
            return NAF.schemas.getComponentsOriginal(template);
        };

        AFRAME.registerComponent('clear-frustum-culling', {
            init: function () {
                let el = this.el;
                el.addEventListener("model-loaded", e => {
                    let mesh = el.getObject3D('mesh');
                    if (!mesh) { return; }
                    mesh.traverse(function (node) {
                        if (node.isMesh) {
                            node.frustumCulled = false;
                        }
                    });
                });
            }
        });

        AFRAME.registerComponent('scene-settings', {
            schema: {
                color: { type: "string", default: "#ffffff" },
                pr_type: { type: "string", default: "default" },
                img_link: { type: "string", default: "no_link" },
                selChoice: { type: "string", default: "0" },
                presChoice: { type: "string", default: "default" },
                movement_disabled: { type: "string", default: "0" },
                cam_position: { type: "string", default: "0 1.6 0" },
                cam_rotation_y: { type: "string", default: "0" },
                avatar_enabled: { type: "string", default: "0" },
                public_chat: { type: "string", default: "0" },
            },
            init: function () {

                let connectionResolve;
                let connectionPromise = new Promise((resolve, reject) => {
                    connectionResolve = resolve;


                })

                connectionPromise.then(() => {
                    // now you can access NAF.connection.getConnectedClients() safely here
                    // do stuff

                    console.log("PROMISE");
                    console.log(NAF.connection.getConnectedClients());
                })
                if (this.data.movement_disabled == "1")
                    if (this.data.pr_type == "vrexpo_games")
                        document.getElementById('cameraA').removeAttribute('wasd-controls');
                    else
                        document.getElementById('player').removeAttribute('wasd-controls');
                // console.log(wasd_controls);


                // Event - When scene is loaded
                this.el.addEventListener("loaded", () => {

                    if (this.data.pr_type === "vrexpo_games") {
                        console.log(this.data.cam_rotation_y);
                        document.getElementById("cameraA").setAttribute("position", this.data.cam_position);
                        //document.getElementById("player").setAttribute("rotation", "0 90 0");

                        //document.getElementById("cameraA").setAttribute("rotation", this.data.cam_rotation);
                    }

                    document.getElementById("private-chat-button").addEventListener("click", () => {
                        let event = new CustomEvent('chat-selected', { "detail": "private" });
                        document.dispatchEvent(event);
                        gtag('event', 'chat_private_tab_selected');
                    });

                    document.getElementById("public-chat-button").addEventListener("click", (evt) => {
                        let event = new CustomEvent('chat-selected', { "detail": "public" });
                        document.dispatchEvent(event);
                        gtag('event', 'chat_public_tab_selected');
                    });

                    if (document.getElementById("aframe-scene-container").getAttribute("scene-settings").public_chat == "0") {

                        document.getElementById("private-chat-button").disabled = true;
                    }
                    else {
                        document.getElementById("public-chat-button").style.visibility = 'visible';
                        document.getElementById("public-chat-button").classList.add('mdc-tab--active');
                        document.getElementById("public-chat-button").disabled = true;
                    }



                    AFRAME.registerComponent('avatar-movement-info', {
                        // notice that color and name are both listed in the schema; NAF will only keep
                        // properties declared in the schema in sync.
                        schema: {
                            movementState: {
                                type: 'string',
                                default: ''
                            }

                        },

                        init: function () {
                            this.rpm_model = this.el.querySelector('.rpm_avatar');
                        },

                        update: function () {

                            if (this.el.querySelector('.rpm_avatar') && this.el.is('anims_loaded')) {
                                //elem.setAttribute("animation-player", evt.detail);
                                if (this.data.movementState != "stop") {
                                    this.el.querySelector('.rpm_avatar').setAttribute("animation-mixer", "clip:" + this.data.movementState + "; crossFadeDuration:0.3;");
                                } else {
                                    this.el.querySelector('.rpm_avatar').setAttribute("animation-mixer", "clip: idle; crossFadeDuration:1;");
                                }

                            }
                        }
                    });

                    AFRAME.registerComponent('avatar-rotation-info', {
                        // notice that color and name are both listed in the schema; NAF will only keep
                        // properties declared in the schema in sync.
                        schema: {
                            rotationState: {
                                type: 'string',
                                default: ''
                            }

                        },

                        init: function () {
                            this.rpm_model = this.el.querySelector('.rpm_avatar');
                        },

                        update: function () {

                            if (this.el.querySelector('.rpm_avatar') && this.el.is('anims_loaded')) {
                                //elem.setAttribute("animation-player", evt.detail);
                                if (this.data.movementState != "stop") {
                                    this.el.querySelector('.rpm_avatar').setAttribute("animation-mixer", "clip:" + this.data.movementState + "; crossFadeDuration:0.3;");
                                } else {
                                    this.el.querySelector('.rpm_avatar').setAttribute("animation-mixer", "clip: idle; crossFadeDuration:1;");
                                }

                            }
                        }
                    });


                    AFRAME.registerComponent('player-info', {
                        // notice that color and name are both listed in the schema; NAF will only keep
                        // properties declared in the schema in sync.
                        schema: {
                            name: {
                                type: 'string',
                                default: 'user-' + Math.round(Math.random() * 10000)
                            },
                            color: {
                                type: 'color', // btw: color is just a string under the hood in A-Frame
                                default: window.ntExample.randomColor()
                            },
                            gltf: {
                                default: '',
                                type: 'string'
                            },
                            avatarType: {
                                default: '',
                                type: 'string'
                            },
                            animationsLoaded: {
                                default: '',
                                type: 'string'
                            },
                            currentPrivateChat: {
                                default: '',
                                type: 'string'
                            },
                            fullChatTable: {
                                default: [],
                                type: 'array'
                            },
                            connectedUsers: {
                                default: 0,
                                type: 'number'
                            }

                        },

                        init: function () {
                            this.head = this.el.querySelector('.head');
                            this.face = this.el.querySelector('.face');
                            this.nametag = this.el.querySelector('.nametag');
                            this.rpm_model = this.el.querySelector('.rpm_avatar');
                            this.anims_loaded = false;

                            var elem = this.el;
                            if (elem.querySelector('.rpm_avatar')) {
                                elem.querySelector('.rpm_avatar').addEventListener('stateadded', function (evt) {
                                    if (evt.detail == 'loadedanimations') {
                                        console.log("Animations loaded");
                                        this.anims_loaded = true;
                                        elem.addState('anims_loaded');

                                    }
                                });


                            }

                            this.avatar_type = this.el.querySelector('.avatar_type');

                            this.ownedByLocalUser = this.el.id === 'cameraA';
                            if (this.ownedByLocalUser) {
                                // populate the html overlay with the correct name on init
                                this.nametagInput = document.getElementById('username-overlay');
                                this.nametagInput.value = this.data.name;

                                // add the initial color to the html overlay color picker button
                                document.getElementById('color-changer').style.backgroundColor = this.data.color;
                                document.getElementById('color-changer').style.color = this.data.color;
                            }
                        },

                        // here as an example, not used in current demo. Could build a user list, expanding on this.
                        listUsers: function () {
                            console.log(
                                'userlist',
                                [...document.querySelectorAll('[player-info]')].map((el) => el.components['player-info'].data.name)
                            );
                        },

                        newRandomColor: function () {
                            this.el.setAttribute('player-info', 'color', window.ntExample.randomColor());
                        },

                        update: function () {

                            var elem = this.el;

                            if (this.data.avatarType) {

                                if (this.data.avatarType === 'no-avatar') {

                                    if (!this.ownedByLocalUser) {
                                        this.head.setAttribute("visible", "false");
                                        this.face.setAttribute("visible", "false");
                                    }

                                    const parent_avatar = document.getElementById('cameraA');
                                    let my_head = parent_avatar.querySelector('.head');
                                    let my_face = parent_avatar.querySelector('.face');
                                    if (my_face) my_face.setAttribute("visible", "false");
                                    if (my_head) my_head.setAttribute("visible", "false");

                                } else if (this.data.avatarType === 'blob') {

                                    if (this.head) {
                                        this.head.setAttribute('material', 'color', this.data.color);
                                        this.head.setAttribute('visible', 'true');
                                        this.face.setAttribute('visible', 'true');
                                    }
                                    if (this.nametag) {
                                        this.nametag.setAttribute('value', this.data.name);
                                        this.nametag.setAttribute('visible', 'true');
                                    }

                                } else if (this.data.avatarType === 'rpm') {

                                    if (this.rpm_model) {
                                        // Set GLTF path to entity
                                        this.rpm_model.removeAttribute('gltf-model');
                                        this.rpm_model.setAttribute('gltf-model', this.data.gltf);


                                        // Event listener when the 3D model has actually loaded
                                        this.rpm_model.addEventListener('model-loaded', () => {

                                            let avatarType = this.rpm_model.object3DMap.mesh.children[0].userData.name;
                                            // Change Y position of model based on type

                                            let avatarPosition = avatarType === 'Armature' ? "0 -1.68  0" : '0 -.4 0';
                                            this.rpm_model.setAttribute('position', avatarPosition);
                                        }, { once: true });
                                    }

                                    if (this.nametag) {
                                        this.nametag.setAttribute('value', this.data.name);
                                        this.nametag.setAttribute('position', '0.25 0.6 0');
                                        this.nametag.setAttribute('visible', 'true');
                                    }
                                }
                            }
                        }
                    });

                    // If base scene, launch avatar selector
                    /*if (document.getElementById("is-base-scene-input").value === 'true' ) {*/

                    console.log(document.getElementById("aframe-scene-container").getAttribute("scene-settings").avatar_enabled);


                    let avatar_dialog_element = new mdc.dialog.MDCDialog(document.querySelector('#avatar-selection-dialog'))

                    let closeAvatarDialogListener = function (event) {
                        avatar_dialog_element.unlisten("MDCDialog:cancel", closeAvatarDialogListener);
                        selectAvatarType('no-avatar');
                    };
                    if (document.getElementById("aframe-scene-container").getAttribute("scene-settings").avatar_enabled == 1 && document.getElementById("aframe-scene-container").getAttribute("scene-settings").pr_type == "vrexpo_games") {
                        avatar_dialog_element.show();
                        avatar_dialog_element.listen("MDCDialog:cancel", closeAvatarDialogListener);
                    } else {
                        selectAvatarType('no-avatar');
                    }

                    /*}*/

                });

                this.el.addEventListener("enter-vr", () => {
                    browsingModeVR = true;
                    gtag('event', 'vr_enabled');
                });
                this.el.addEventListener("exit-vr", () => {
                    browsingModeVR = false;
                    gtag('event', 'vr_disabled');
                });

                let cam = document.querySelector("#cameraA");

                if (this.data.pr_type !== "vrexpo_games")
                    cam.setAttribute("camera", "fov: 60");
                else {
                    cam.setAttribute("fov", "60");
                    cam.setAttribute("camera", "fov: 60"); //temp based on camera settings

                    // Hide eyes from my avatar on self
                    const parent_avatar = document.getElementById('cameraA');
                    let my_face = parent_avatar.querySelector('.face');
                    if (my_face) my_face.setAttribute("visible", "false");

                }

                let backgroundEl = document.querySelector('#aframe-scene-container');

                if (!this.data.selChoice)
                    this.data.selChoice = "0";

                switch (this.data.selChoice) {
                    case "0":
                        // Background: Horizon (Using Environment Component)

                        // 1. Remove standard background attribute
                        backgroundEl.removeAttribute("background");

                        // 2. Remove old incompatible sun-sky tag
                        let oldSun = document.querySelector('a-sun-sky');
                        if (oldSun) oldSun.parentNode.removeChild(oldSun);

                        // 3. Remove manual sky/sun if they exist (from previous tests)
                        let manSky = document.getElementById('default-sky');
                        if (manSky) manSky.parentNode.removeChild(manSky);
                        let manSun = document.getElementById('default-sun');
                        if (manSun) manSun.parentNode.removeChild(manSun);

                        // 4. Activate Environment: Default Preset (Sun + Atmosphere + Flat Ground)
                        backgroundEl.setAttribute("environment", {
                            preset: 'default',
                            skyType: 'atmosphere', // Generates sun and horizon
                            lighting: 'distant',   // Sun light
                            ground: 'none',        // Simple ground to see the horizon
                            playArea: 1,
                            shadow: true
                        });

                        break;
                    case "1":

                        // Background: Color
                        // 1. Turn off Environment (Removes Sun/Horizon)
                        backgroundEl.removeAttribute("environment");

                        // 2. Remove manual sky/sun if they exist
                        let manSky1 = document.getElementById('default-sky');
                        if (manSky1) manSky1.parentNode.removeChild(manSky1);
                        let manSun1 = document.getElementById('default-sun');
                        if (manSun1) manSun1.parentNode.removeChild(manSun1);

                        // 3. Remove old incompatible sun-sky
                        let oldSun1 = document.querySelector('a-sun-sky');
                        if (oldSun1) oldSun1.parentNode.removeChild(oldSun1);

                        // 4. Set Color
                        backgroundEl.setAttribute("background", "color", this.data.color);
                        break;
                    case "2":

                        // 1. Remove manual sky/sun
                        let manSky2 = document.getElementById('default-sky');
                        if (manSky2) manSky2.parentNode.removeChild(manSky2);
                        let manSun2 = document.getElementById('default-sun');
                        if (manSun2) manSun2.parentNode.removeChild(manSun2);

                        // 2. Remove old sun-sky
                        let oldSun2 = document.querySelector('a-sun-sky');
                        if (oldSun2) oldSun2.parentNode.removeChild(oldSun2);

                        // Presets
                        if (this.data.presChoice == "ocean") {

                            // Disable environment for ocean mode (uses custom primitives)
                            backgroundEl.removeAttribute("environment");

                            let sky = document.createElement('a-sky');
                            sky.setAttribute("color", "#a4bede");
                            backgroundEl.appendChild(sky);

                            let plane = document.createElement('a-plane');
                            plane.setAttribute("color", "#ffffff");
                            plane.setAttribute("position", "0 4.5 0");
                            plane.setAttribute("height", "11");
                            plane.setAttribute("width", "11");
                            plane.setAttribute("rotation", "90 90 0");
                            plane.setAttribute("material", "opacity:0.4");
                            plane.setAttribute("scale", "15 15 15");
                            plane.setAttribute("class", "ocean_asset");
                            backgroundEl.appendChild(plane);

                            let entity = document.createElement('a-entity');
                            entity.setAttribute("color", "#b6e8fe");
                            entity.setAttribute("position", "0 4 0");
                            entity.setAttribute("class", "ocean_asset");

                            let ocean_top = document.createElement('a-ocean');
                            ocean_top.setAttribute("width", "50");
                            ocean_top.setAttribute("depth", "50");
                            ocean_top.setAttribute("density", "40");
                            ocean_top.setAttribute("class", "ocean_asset");



                            let animation = document.createElement('a-animation');
                            animation.setAttribute("attribute", "visible");
                            animation.setAttribute("delay", "25000");
                            animation.setAttribute("to", "true");

                            ocean_top.setAttribute('animation', {
                                property: 'visible',
                                to: true,
                                delay: 25000,
                                dur: 1
                            });

                            entity.appendChild(ocean_top);
                            backgroundEl.appendChild(entity);


                            let ocean_shadow = document.createElement('a-ocean');
                            ocean_shadow.setAttribute("width", "50");
                            ocean_shadow.setAttribute("depth", "50");
                            ocean_shadow.setAttribute("density", "50");
                            ocean_shadow.setAttribute("color", "#75705e");
                            ocean_shadow.setAttribute("position", "0 -0.15 0");
                            ocean_shadow.setAttribute("opacity", "0.03");
                            ocean_shadow.setAttribute("class", "ocean_asset");

                            let animation_shadow = document.createElement('a-animation');
                            animation_shadow.setAttribute("attribute", "visible");
                            animation_shadow.setAttribute("delay", "55000");
                            animation_shadow.setAttribute("to", "true");

                            ocean_shadow.appendChild(animation_shadow);

                            backgroundEl.appendChild(ocean_shadow);

                            let plane_seafloor = document.createElement('a-plane');
                            plane_seafloor.setAttribute("id", "seafloorCoral");
                            plane_seafloor.setAttribute("color", "#d9d0ae");
                            plane_seafloor.setAttribute("position", "0 0 0");
                            plane_seafloor.setAttribute("height", "4");
                            plane_seafloor.setAttribute("width", "4");
                            plane_seafloor.setAttribute("rotation", "-90 0 0");
                            plane_seafloor.setAttribute("scale", "15 15 15");
                            plane_seafloor.setAttribute("class", "ocean_asset");

                            backgroundEl.appendChild(plane_seafloor);

                            let light_a = document.createElement('a-entity');
                            light_a.setAttribute("light", "type: hemisphere; color: #ffffff; groundColor: #000000; intensity: 0.9;");
                            light_a.setAttribute("position", "25 8 -25");

                            let light_b = document.createElement('a-entity');
                            light_b.setAttribute("light", "type: hemisphere; color: #ffffff; groundColor: #000000; intensity: 0.3;");
                            light_b.setAttribute("position", "25 8 25");

                            let light_c = document.createElement('a-entity');
                            light_c.setAttribute("light", "type: ambient; color: #ffffff; intensity: 0.5;");
                            light_c.setAttribute("position", "25 8 -25");

                            backgroundEl.appendChild(light_a);
                            backgroundEl.appendChild(light_b);
                            backgroundEl.appendChild(light_c);


                            let audio_track = document.createElement('audio');
                            audio_track.setAttribute("preload", "auto");
                            audio_track.setAttribute("id", "underwater-sound");
                            audio_track.setAttribute("src", "../media/sound/underwater.mp3");

                            backgroundEl.appendChild(audio_track);

                            let sound = document.createElement('a-entity');
                            sound.setAttribute("sound", "src: #underwater-sound; loop: true; volume: 1; positional:false");
                            sound.setAttribute("position", "0 4 0");
                            sound.setAttribute("autoplay-sound", "");

                            backgroundEl.appendChild(sound);


                            backgroundEl.setAttribute("fog", "type: exponential; color: #0894d3; density: 0.06;");


                        } else {
                            backgroundEl.setAttribute("environment", "preset", this.data.presChoice);
                            backgroundEl.setAttribute("environment", "ground", "flat");
                            backgroundEl.setAttribute("environment", "playArea", "1.4");
                            backgroundEl.setAttribute("environment", "shadow", "true");

                            // 4. Update ground shadow
                            let groundEl = document.getElementsByClassName('environmentGround')[0];
                            if (groundEl) {
                                groundEl.setAttribute("shadow", "cast: true; receive: true");
                            }
                        }


                        break;
                    case "3":

                        let customImgAsset = document.querySelector('#custom_sky');
                        if (customImgAsset.getAttribute("src")) {
                            let skyElem = document.createElement('a-sky');
                            skyElem.setAttribute("id", "sky");
                            skyElem.setAttribute("src", "#custom_sky");
                            backgroundEl.appendChild(skyElem);
                        }
                        else {
                            backgroundEl.setAttribute("background", "color", "#ffffff");
                        }


                        break;
                }
            }
        });
        AFRAME.registerComponent('autoplay-sound', {
            init: function () {
                this.el.addEventListener("loaded", () => {
                    this.el.components.sound.playSound();
                });
            }
        });

        AFRAME.registerComponent('entity-movement-emitter', {
            schema: {
                clip: { type: "string", default: "idle" },
            },
            init: function () {

                var bind = AFRAME.utils.bind;
                var shouldCaptureKeyEvent = AFRAME.utils.shouldCaptureKeyEvent;
                var elem = this.el;

                document.addEventListener('keydown', function (event) {
                    if (event.keyCode === 87) {
                        if (shouldCaptureKeyEvent(event)) {
                            document.getElementById('cameraA').setAttribute('avatar-movement-info', 'movementState', "walkingforward");
                        }
                    } else if (event.keyCode === 83) {
                        if (shouldCaptureKeyEvent(event)) {
                            elem.emit('avatar-changed-animation', "walkingdown", false);
                            document.getElementById('cameraA').setAttribute('avatar-movement-info', 'movementState', "walkingdown");
                        }

                    } else if (event.keyCode === 68) {
                        if (shouldCaptureKeyEvent(event)) {
                            elem.emit('avatar-changed-animation', "walkingright", false);
                            document.getElementById('cameraA').setAttribute('avatar-movement-info', 'movementState', "walkingright");
                        }

                    } else if (event.keyCode === 65) {
                        if (shouldCaptureKeyEvent(event)) {
                            elem.emit('avatar-changed-animation', "walkingleft", false);
                            document.getElementById('cameraA').setAttribute('avatar-movement-info', 'movementState', "walkingleft");
                        }
                    }
                    else {
                        elem.emit('avatar-changed-animation', "idle", false);
                    }

                });
                document.addEventListener('keyup', function (event) {
                    elem.emit('avatar-changed-animation', "stopped", false);
                    document.getElementById('cameraA').setAttribute('avatar-movement-info', 'movementState', "stop");
                });


            }
        });

        AFRAME.registerComponent('entity-rotation-emitter', {
            init: function () {

                var bind = AFRAME.utils.bind;
                this.el.addEventListener('componentchanged', function (evt) {
                    if (evt.detail.name === 'rotation') {
                        console.log('Entity has rotated');
                    }
                    //console.log(evt.detail);
                });
            }
        });



        AFRAME.registerComponent('animation-embed', {
            schema: {
                clip: { type: "string", default: "idle" },
                glb_id: { type: "string", default: "" }
            },
            init: function () {
                const animations = ["idle", "walking"];
                var loader = new THREE.GLTFLoader();
                var id = this.data.glb_id;

                this.el.addEventListener("model-loaded", e => {
                    var objectMesh = this.el.getObject3D("mesh");

                    var bind = AFRAME.utils.bind;
                    var shouldCaptureKeyEvent = AFRAME.utils.shouldCaptureKeyEvent;
                    var link = "../assets/templates/multimalev2.glb";
                    var elem = this.el;
                    this.loaded_anims = false;
                    if (this.el.object3DMap.mesh.children[0].userData.name === "Armature") {
                        loader.load(link, function (gltf) {
                            for (let i = 0; i < gltf.animations.length; i++) {
                                objectMesh.animations[i] = gltf.animations[i];
                            }
                            elem.removeAttribute('animation-mixer');
                            elem.setAttribute('animation-mixer', "clip: idle");
                            elem.addState('loadedanimations');
                        });
                    } else {
                        elem.addState('noanimations');

                        elem.object3D.traverse((child) => {
                            if (child.name.includes('Hand')) {
                                child.visible = false;
                            }
                        });
                    }
                });
            }
        });

        AFRAME.registerComponent('static-mask-me', {
            init: function () {
                let el = this.el;
                // el.addEventListener("model-loaded", e => {
                const maskMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: false,
                    colorWrite: false,
                });
                maskMaterial.needsUpdate = true;
                let mesh = el.getObject3D('mesh');
                if (!mesh) {
                    return;
                }
                mesh.traverse(node => {
                    if (!node.isMesh) {
                        return;
                    }
                    node.material = maskMaterial;
                    node.renderOrder = 999;
                });
                //  });
            },
            tick: null
        });

        AFRAME.registerComponent('render-order-change', {
            schema: {
                renderingOrderArg: { type: 'string', default: '2000' }
            },
            init: function () {
                let el = this.el;
                // el.addEventListener("model-loaded", e => {
                let mesh = el.getObject3D('mesh');
                if (!mesh) {
                    return;
                }
                mesh.traverse(node => {
                    if (!node.isMesh) {
                        return;
                    }
                    node.renderOrder = this.data.renderingOrderArg;

                });
                //  });
            },
            tick: null
        });


        AFRAME.registerComponent("overlay", {
            dependencies: ['material'],
            init: function () {
                this.el.sceneEl.renderer.sortObjects = true;
                this.el.object3D.renderOrder = 100;
                this.el.components.material.material.depthTest = false;
            }
        })




        AFRAME.registerComponent('show-position', {
            init: function () {
                this.positionShow = document.getElementById("positionShow");
                this.occupantsNumberShow = document.getElementById("occupantsNumberShow");
            },
            tick: function (time, timeDelta) {
                let p = this.el.getAttribute('position');
                this.positionShow.innerHTML = Math.round(p.x * 100) / 100 + ", " + Math.round(p.y * 100) / 100 + ", " + Math.round(p.z * 100) / 100;

                let occupants = window.easyrtc.getRoomOccupantsAsMap(window.NAF.room);
                if (occupants) {
                    this.occupantsNumberShow.innerHTML = Object.keys(occupants).length;
                }
            }
        });

        AFRAME.registerComponent('custom-movement', {
            init: function () {
                const cameraEl = document.querySelector('a-camera');
                const cameraRig = this.el;

                //console.log (cameraEl);

                const thumbL = document.querySelector('#leftHand');
                const thumbR = document.querySelector('#rightHand');

                thumbL.addEventListener('thumbstickmoved', (event) => {
                    // const thumbstickX = event.detail.x;
                    // const thumbstickY = event.detail.y;

                    // // Get camera rotation
                    // const rotation = cameraEl.getAttribute('rotation');
                    // const angleY = (rotation.y * Math.PI) / 180;


                    // // Calculate movement direction based on camera rotation
                    // const direction = new THREE.Vector3(-Math.sin(angleY), 0, -Math.cos(angleY));

                    // // Apply movement to the camera rig's position
                    // const movementSpeed = 0.1;
                    // cameraRig.object3D.translateX(-direction.x * thumbstickY * movementSpeed - direction.z * thumbstickX * movementSpeed);
                    // cameraRig.object3D.translateZ(-direction.z * thumbstickY * movementSpeed + direction.x * thumbstickX * movementSpeed);


                    // //console.log('Camera rotation:', rotation.x, rotation.y, rotation.z);
                });

                thumbR.addEventListener('thumbstickmoved', (event) => {

                    const thumbstickX = event.detail.x;
                    const thumbstickY = event.detail.y;

                    // Get camera rotation
                    const rotation = cameraEl.getAttribute('rotation');
                    const angleY = (rotation.y * Math.PI) / 180;


                    // Calculate movement direction based on camera rotation
                    const direction = new THREE.Vector3(-Math.sin(angleY), 0, -Math.cos(angleY));

                    // Apply movement to the camera rig's position
                    const movementSpeed = 0.1;
                    cameraRig.object3D.translateX(-direction.x * thumbstickY * movementSpeed - direction.z * thumbstickX * movementSpeed);
                    cameraRig.object3D.translateZ(-direction.z * thumbstickY * movementSpeed + direction.x * thumbstickX * movementSpeed);


                    //console.log('Camera rotation:', rotation.x, rotation.y, rotation.z);
                });

                thumbR.addEventListener('thumbstickmoved', (event) => {

                    // //console.log('Right thumbstick activated');
                    // if (event.detail.y === 1) {  // Assuming y value of thumbstick indicates a button press
                    //     const blinkControlsScript = document.createElement('script');
                    //     blinkControlsScript.src = 'https://cdn.jsdelivr.net/npm/aframe-blink-controls/dist/aframe-blink-controls.min.js';
                    //     document.head.appendChild(blinkControlsScript);

                    //     blinkControlsScript.onload = () => {
                    //     console.log('aframe-blink-controls script loaded');
                    //     };
                    // }


                });

            }
        });

        AFRAME.registerComponent('start-animation', {
            init: function () {

                const avatar = document.getElementById('animated_avatar');
                /*const animationModel = document.querySelector('#animation-model');*/

                // Trigger the animation when the scene starts
                //animationModel.emit('start-scene');

                // Show the avatar and animation models
                //avatar.setAttribute('visible', 'true');

                //console.log("test");
                //animationModel.setAttribute('visible', 'true');
            }
        });

    </script>

    <style>
        .button-tab {
            background-color: #fff;
            border: none;
            border-radius: 1.5rem;
            box-sizing: border-box;
            color: #0d172a;
            cursor: pointer;
            display: inline-block;
            font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans,
                Droid Sans, Helvetica Neue, sans-serif;
            font-size: 0.8em;
            font-weight: 600;
            padding: 0;
            text-align: center;
            text-decoration: none #0d172a solid;
            transition: all .1s cubic-bezier(.4, 0, .2, 1);
            box-shadow: 0 1px 2px rgba(166, 175, 195, 0.25);
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .mdc-tab {
            background-color: rgba(255, 255, 255, .54);
            color: rgba(0, 0, 0, .23);
        }

        .mdc-tab--active {
            background-color: white;
            color: black;
        }

        .ChatWrapperStyle {
            position: absolute;
            bottom: 0;
            height: auto;
        }

        .ChatWrapperStyleExpanded {
            position: absolute;
            height: auto;
        }

        .ChatMessagesStyle {
            width: 450px;
            background-color: rgba(0, 0, 0, .7);
            overflow: auto;
            z-index: 100;
            bottom: 0;
            left: 0;
            display: flex;
            flex-direction: column-reverse;
            font-family: Arial, Helvetica, sans-serif;
            font-size: 14px;
            color: #ccc;
            text-shadow: 1px 1px 2px black;
        }

        .ChatMessagesStyleNormal {
            height: 200px;
            position: relative;
        }

        .ChatMessagesStyleExpanded {
            height: 100%;
            position: fixed;
        }

        .ChatMessagesStyleMinimized {
            height: 0;
            position: relative;
        }

        .IconButtonStyle {
            background-color: transparent;
            cursor: pointer;
            border: none;
            height: 24px;
            width: 24px;
            margin: 0 auto;
            padding: 0 2px 0 2px;
        }

        .IconButtonStyle i {
            text-shadow: 0 0 3px #fff;
        }

        .AvatarTypeSelection img {
            display: block;
        }

        .AvatarTypeSelection label {
            /*width: 20vw;
            height: 20vw;*/
            padding: 1vw;
        }

        .AvatarTypeSelection input[type=radio] {
            display: none;
        }

        .AvatarTypeSelection label:hover {
            opacity: 0.6;
            cursor: pointer;
        }

        .AvatarTypeSelection label:active {
            opacity: 0.4;
            cursor: pointer;
        }

        .AvatarTypeSelection input[type=radio]:checked+label {
            border: 10px solid rgb(228, 207, 94);
        }

        .RpmIframeStyle {
            width: 1080px;
            height: 800px;
            margin: 0 auto;
            font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans,
                Droid Sans, Helvetica Neue, sans-serif;
            padding: 20px;
            font-size: 14px;
            border: none;
            position: relative;
            z-index: 9999;
        }
    </style>

</head>

<body id="master-client-body">

    <div class="ChatWrapperStyle" id="chat-wrapper-el" style="visibility: hidden">

        <div class="mdc-tab-bar" role="tablist"
            style="position: relative; top: 0; right:30px; z-index:101; height: 30px;">
            <div class="mdc-tab-scroller">

                <button id="public-chat-button" class="mdc-tab button-tab" role="tab" aria-selected="true" tabindex="0"
                    style="visibility: hidden">
                    <span class="mdc-tab__content">
                        <span class="mdc-tab__text-label">Public</span>
                    </span>

                </button>

                <button id="private-chat-button" class="mdc-tab button-tab" role="tab" aria-selected="true" tabindex="1"
                    style="visibility: hidden">
                    <span class="mdc-tab__content">
                        <span id="private-chat-button-label" class="mdc-tab__text-label">Private</span>
                    </span>

                </button>

            </div>

        </div>


        <div id="chatControlsOverlay" style="position: relative; top: 0; left:0; z-index:101; height: 30px;">
            <button id="color-changer" onclick="
            let newColor = window.ntExample.randomColor();
             document.getElementById('cameraA').setAttribute('player-info', 'color', newColor);
             document.getElementById('color-changer').style.backgroundColor = newColor;
             document.getElementById('color-changer').style.color = newColor;
             gtag('event', 'player_color_change');
        ">â– </button>
            <input id="username-overlay" maxlength="24" size="15"
                oninput="document.getElementById('cameraA').setAttribute('player-info', 'name', this.value)"
                placeholder="Username" />
            <input type="text" id="chatInput" placeholder="Message">
            <button id="send-msg-chat-btn" style="right: 0; cursor: pointer">SEND</button>
            <button id="expand-chat-btn" class="IconButtonStyle" title="Chat Size"><i
                    class="material-icons">unfold_more</i></button>
            <button id="minimize-chat-btn" class="IconButtonStyle" title="Minimize"><i
                    class="material-icons">expand_more</i></button>
            <button id="exit-help-btn" class="IconButtonStyle" title="Exit Private Chat" style="display: none"><i
                    class="material-icons">close</i></button>
        </div>
        <div class="ChatMessagesStyle ChatMessagesStyleNormal" id="chat-messages-wrapper">
            <div id="chat-messages"></div>
        </div>
    </div>

    <div id="mediaPanel">
        <div class="wrapperVideoElement" style="visibility: hidden">
            <video id="video-preview" width="300" height="200" autoplay muted></video>
            <video id="recording" hidden></video>
        </div>

        <div class="actionsDirector" name="actionsDiv" id="actionsDiv">
            <div id="toggle_controls">Close <span style="color: white">("x" button to show again)</span></div>
            <div id="directorline" style=""></div>


            <div class="wrapperControlElement">
                <label for="roomNameShow" title="Name of Room">&#127917;</label>
                <span id="roomNameShow">roomname</span>
            </div>

            <div class="wrapperControlElement">
                <label for="occupantsNumberShow" title="Number of actors">&#128101;</label>
                <span id="occupantsNumberShow"></span>
            </div>

            <div class="wrapperControlElement">
                <button id="obtainStatusAndSetSizeControls" class="buttonMultiplaying"
                    title="Obtain status and control green screens">
                    &#128260; &#9989;
                </button>
            </div>

            <div class="wrapperControlElement">
                <button id="screen-btn-sendscreen" class="buttonMultiplaying" title="Send scene stream back to actors">
                    &#127909; &#9654; &#128101;
                </button>
            </div>

            <div class="wrapperControlLineElement">
                <button id="start-recording-btn" class="buttonStartRecord" title="Start capturing video">
                    âšªï¸
                </button>

                <a id="download-recording-btn" class="buttonDownloadRecording" title="Download video"
                    style="visibility: hidden">
                    ðŸ’¾ï¸ï¸
                </a>

                <button id="upload-recording-btn" class="buttonUploadRecording" style="visibility: hidden;"
                    title="Upload Recording to MediaVerse" disabled>
                    â¬†ï¸ï¸ï¸
                </button>
            </div>
            <div class="wrapperControlElement">
                <span id="captured-video-label"></span>
            </div>
            <div class="wrapperControlElement">
                <label for="positionShow" title="Camera Position">&#127909;</label>
                <span id="positionShow"></span>
            </div>

            <div id="panelsSizeControlsDiv"></div>
            <input id="node-url-input" hidden disabled />
            <input id="node-token-input" hidden disabled />
            <input id="is-base-scene-input" hidden disabled />
        </div>
    </div>


    <!-- Avatar selection -->
    <aside id="avatar-selection-dialog" class="mdc-dialog" role="alertdialog" style="z-index: 1000;"
        aria-labelledby="Avatar selection popup" aria-describedby="You can select an avatar"
        data-mdc-auto-init="MDCDialog">
        <div class="mdc-dialog__surface">
            <header class="mdc-dialog__header">
                <h2 class="mdc-dialog__header__title">Welcome to our virtual exposition</h2>
            </header>

            <section class="mdc-dialog__body">
                <div class="mdc-layout-grid">
                    <div class="mdc-layout-grid__inner">
                        <div class="mdc-layout-grid__cell--span-12">
                            <div style="text-align: center">
                                <h3 class="mdc-typography--headline">Please select an avatar type:</h3>
                                <form name="avatarRadiosForm">
                                    <div class="mdc-form-field AvatarTypeSelection">
                                        <input class="mdc-radio__native-control" type="radio" id="no-avatar-radio"
                                            name="avatar-radios" value="no-avatar" checked>
                                        <label for="no-avatar-radio">
                                            <img src="media/img/no-avatar.png" width="128" height="128"
                                                style="opacity:.6" />
                                            <span>No avatar</span>
                                        </label>

                                        <input class="mdc-radio__native-control" type="radio" id="blob-radio"
                                            value="blob" name="avatar-radios">
                                        <label for="blob-radio">
                                            <img src="media/img/blob-avatar.png" width="128" height="128" />
                                            <span>A Blob</span>
                                            <br>
                                            <span>(Default)</span>
                                        </label>

                                        <input class="mdc-radio__native-control" type="radio" id="rpm-radio" value="rpm"
                                            name="avatar-radios">
                                        <label for="rpm-radio">
                                            <img src="media/img/rpm-avatar.png" width="128" height="128" />
                                            <span>Your personalized</span>
                                            <br>
                                            <span>3D avatar</span>
                                        </label>
                                    </div>
                                </form>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <footer class="mdc-dialog__footer">
                <a id="selectAvatarBtn" onclick="selectAvatarType()"
                    class="mdc-button mdc-button--primary mdc-dialog__footer__button mdc-dialog__footer__button--accept mdc-button--raised">OK</a>
            </footer>
        </div>
        <div class="mdc-dialog__backdrop"></div>
    </aside>


    <!-- IMG POI Dialog component -->
    <aside id="poi-img-dialog" class="mdc-dialog" role="alertdialog" style="z-index: 1000;"
        aria-labelledby="Image POI popup" aria-describedby="Show Image POI details" data-mdc-auto-init="MDCDialog">
        <div class="mdc-dialog__surface">
            <header class="mdc-dialog__header">
                <h2 id="poi-img-dialog-title" class="mdc-dialog__header__title"></h2>
            </header>

            <section class="mdc-dialog__body">
                <div class="mdc-layout-grid">
                    <div class="mdc-layout-grid__inner">
                        <div class="mdc-layout-grid__cell--span-12">
                            <div style="text-align: center">
                                <img src="" alt="Image POI Image" id="poi-img-dialog-image"
                                    style="width: auto; max-width: 100%;max-height: 260px;" />
                            </div>
                            <div style="text-align: left; overflow-y: auto;  max-height: 300px;">
                                <span class="mdc-typography--body1" id="poi-img-dialog-description"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <footer class="mdc-dialog__footer">
                <a
                    class="mdc-button mdc-button--primary mdc-dialog__footer__button mdc-dialog__footer__button--accept mdc-button--raised">OK</a>
            </footer>
        </div>
        <div class="mdc-dialog__backdrop"></div>
    </aside>

    <aside id="video-controls-dialog" class="mdc-dialog" role="alertdialog" style="z-index: 1000;"
        aria-labelledby="Video controls popup" aria-describedby="Show Video controls">
        <div class="mdc-dialog__surface">

            <video controls controlsList="nodownload" id="video-panel-video" height="100%" width="100%">
                Your browser does not support video.
            </video>

            <footer class="mdc-dialog__footer">
                <a
                    class="mdc-button mdc-button--primary mdc-dialog__footer__button mdc-dialog__footer__button--cancel mdc-button--raised">Close</a>
                <a class="mdc-button mdc-button--primary mdc-dialog__footer__button mdc-dialog__footer__button--accept mdc-button--raised"
                    style="display: none;" tabIndex="0">OK</a>
            </footer>
        </div>
        <div class="mdc-dialog__backdrop"></div>
    </aside>

    <!--Ready Player Me iframe-->
    <div style="text-align: center;">
        <iframe id="rpm-iframe" class="RpmIframeStyle" allow="camera *; microphone *; clipboard-write" hidden></iframe>
    </div>

    <a-scene oculus-go-controls-enabled start-animation id="aframe-scene-container"
        fog="type: linear; color: #AAB; far: 230; near: 0" renderer="antialias: true;
            sortTransparentObjects: true;
            toneMapping: ACESFilmic;
            precision: high;
            alpha: true;" shadow="type: pcfsoft;" vr-mode-ui="enabled: true"
        loading-screen="dotsColor: gray; backgroundColor: black;">
        <!--environment="ground:none"-->

        <a-assets id="scene-assets">

            <!-- Avatar Template -->
            <template id="avatar-template-expo">
                <a-entity class="avatar hideable" player-info avatar-movement-info>


                    <!-- ReadyPlayerMe Avatar-->
                    <a-entity gltf-model animation-embed="glb_id:ready-player-me-avatar" id="ready-player-me-avatar"
                        class="rpm_avatar" position="0 0 -0.5" rotation="0 180 0" animation-mixer="clip: test;"
                        visible="true" shadow="cast:true; receive:true;">
                    </a-entity>

                    <!-- Sphere Avatar-->
                    <a-sphere class="head" scale="0.2 0.18 0.2" visible="false"
                        shadow="cast:true; receive:true;"></a-sphere>
                    <a-entity class="face" position="0 0.05 0" visible="false">
                        <a-sphere class="eye" color="white" position="0.06 0.05 -0.16" scale="0.04 0.04 0.04">
                            <a-sphere class="pupil" color="black" position="0 0 -1" scale="0.2 0.2 0.2"></a-sphere>
                        </a-sphere>
                        <a-sphere class="eye" color="white" position="-0.06 0.05 -0.16" scale="0.04 0.04 0.04">
                            <a-sphere class="pupil" color="black" position="0 0 -1" scale="0.2 0.2 0.2"></a-sphere>
                        </a-sphere>
                    </a-entity>


                    <!-- Text component for a nametag; the value will be updated by the player-info component -->
                    <a-text class="nametag" value="?" rotation="0 180 0" position="0.25 -0.35 0" side="double"
                        scale=".5 .5 .5" visible="false"></a-text>
                </a-entity>
            </template>

            <!-- Avatar template for MediaVerse projects-->
            <template id="avatar-template">
                <a-entity class="avatar hideable" networked-audio-source>

                    <a-plane id="videoPlaneGreen" class="videoPlaneGreenClass" color="#FFF" width="2" height="1.5"
                        position="0 0.6 -0.15" material="side: double"
                        networked-video-source="useGreenScreen: true; greenThreshold: 0.04; streamName: video"
                        render-order-change="2000">
                    </a-plane>

                    <a-plane id="screenPlane" color="#FFF" width="0" height="0" position="0 0.6 -0.15"
                        material="side: double" networked-video-source="streamName:screen">
                    </a-plane>
                </a-entity>
            </template>

            <a-mixin id="vid_panel" geometry="primitive: plane; width: 0.5783552; height: 0.8192"
                material="color: black; shader: flat"></a-mixin>
            <a-mixin id="frame" geometry="primitive: plane; width: 0.5783552; height: 0.8192"
                material="color: white; shader: flat"
                animation__scale="property: scale; to: 1.2 1.2 1.2; dur: 200;  startEvents: tmp1"
                animation__scale_reverse="property: scale; to: 1 1 1; dur: 200; startEvents: tmp2"></a-mixin>
            <a-mixin id="poster" geometry="primitive: plane; width: 0.544768; height: 0.786432"
                material="color: white; shader: flat" position="0 0 0.005"></a-mixin>
            <a-mixin id="poiImage" geometry="primitive: plane; width: 1.4; height: 0.8"
                material="shader: flat;  transparent: true" position="0 0.455 0.002"></a-mixin>
            <a-mixin id="poiImageFull" geometry="primitive: plane; width: 1.4; height: 1.4"
                material="shader: flat; transparent: true" position="0 0 0.002"></a-mixin>
            <a-mixin id="poiEsc" geometry="primitive: plane; width: 1; height: 1" position="1 0.73 0.002"
                material="shader: flat; transparent: true"></a-mixin>
            <a-mixin id="poiImgNext" geometry="primitive: plane; width: 1; height: 1"
                material="shader: flat; transparent: true" position="1 -0.5 0.002"></a-mixin>
            <a-mixin id="poiImgPrev" geometry="primitive: plane; width: 1; height: 1"
                material="shader: flat; transparent: true" position="-1 -0.5 0.002"></a-mixin>
            <a-mixin id="poiEscFrame" geometry="primitive: circle; radius: 0.15"
                material="shader: flat; color: #dfe4ea; depthTest: false; transparent: true"
                position="1 0.73 0.002"></a-mixin>
            <a-mixin id="poiImgPrevFrame" geometry="primitive: circle; radius: 0.15"
                material="shader: flat; color: #dfe4ea; depthTest: false; transparent: true"
                position="-1 -0.5 0.002"></a-mixin>
            <a-mixin id="poiImgNextFrame" geometry="primitive: circle; radius: 0.15"
                material="shader: flat; color: #dfe4ea; depthTest: false; transparent: true"
                position=" 1 -0.5 0.002"></a-mixin>
            <a-mixin id="vidFrame" geometry="primitive: plane; width: 0.4; height: 0.14"
                material="shader: flat; color: #dfe4ea; " position=" 0 0 0.000001"></a-mixin>
            <a-mixin id="poiVidEscFrame" geometry="primitive: circle; radius: 0.05"
                material="shader: flat; color: #dfe4ea; depthTest: false; transparent: true; "
                position="0.15 0.15 0.000001"></a-mixin>


        </a-assets>

        <a-entity id="player"></a-entity>
        <a-entity id="actor"></a-entity>

        <!-- oculus hands -->
        <a-entity id="leftHand" oculus-touch-controls="hand: left" visible="false"></a-entity>
        <a-entity id="rightHand" oculus-touch-controls="hand: right" visible="false" blink-controls></a-entity>


    </a-scene>


    <script>

        // All asets have loaded
        document.querySelector('#scene-assets').addEventListener('loaded', function () {

            // Don't show HTML component (chat) while loader is active
            if (document.getElementById("chat-wrapper-el").getAttribute('data-visible') === 'true') {
                document.getElementById("chat-wrapper-el").style.visibility = 'visible';
            }

        });

        let selectAvatarType = (val) => {

            let radioVal = val ? val : document.querySelector('input[name="avatar-radios"]:checked').value;

            document.getElementById('cameraA').setAttribute('player-info', 'avatarType', radioVal);
            if (radioVal === 'rpm') {
                document.getElementById('rpm-iframe').hidden = false;
            }
        }

        // Ready player me iframe code
        const subdomain = 'vrodos'; // Replace with your custom subdomain
        const rpm_iframe = document.getElementById('rpm-iframe');
        rpm_iframe.src = `https://${subdomain}.readyplayer.me/avatar?frameApi`;

        window.addEventListener('message', subscribe);
        document.addEventListener('message', subscribe);

        function subscribe(event) {
            const json = parseRPMEvent(event);

            if (json?.source !== 'readyplayerme') {
                return;
            }

            // Susbribe to all events sent from Ready Player Me once frame is ready
            if (json.eventName === 'v1.frame.ready') {
                rpm_iframe.contentWindow.postMessage(
                    JSON.stringify({
                        target: 'readyplayerme',
                        type: 'subscribe',
                        eventName: 'v1.**'
                    }),
                    '*'
                );
            }

            // Get avatar GLB URL
            // Now add it in Aframe canvas
            if (json.eventName === 'v1.avatar.exported') {
                document.getElementById('rpm-iframe').hidden = true;

                // Update remote
                document.getElementById('cameraA').setAttribute('player-info', 'gltf', json.data.url);

            }

            // Get user id
            if (json.eventName === 'v1.user.set') {
                console.log(`User with id ${json.data.id} set: ${JSON.stringify(json)}`);
            }
        }

        function parseRPMEvent(event) {
            try {
                return JSON.parse(event.data);
            } catch (error) {
                return null;
            }
        }


        const api_pattern_single = {
            ThresholdMin: 0.106,
            ThresholdMax: 0.13,
            red: 48, green: 146, blue: 89,
            w: 1, h: 0.75,
            x: 0, y: 0, z: 0,
            rx: 0, ry: 0, rz: 0
        };

        const api_pattern_singleMin = {
            ThresholdMinLow: 0,
            ThresholdMaxLow: 0,
            redLow: 0,
            greenLow: 0,
            blueLow: 0,
            wLow: 0.1,
            hLow: 0.1,
            xLow: -100000,
            yLow: -100000,
            zLow: -100000,
            rxLow: -100,
            ryLow: -100,
            rzLow: -100
        };
        const api_pattern_singleMax = {
            ThresholdMinHigh: 0.4,
            ThresholdMaxHigh: 0.4,
            redHigh: 255,
            greenHigh: 255,
            blueHigh: 255,
            wHigh: 5,
            hHigh: 5,
            xHigh: 100000,
            yHigh: 100000,
            zHigh: 100000,
            rxHigh: 100,
            ryHigh: 100,
            rzHigh: 100
        };
        const api_pattern_singleStep = {
            ThresholdMinStep: 0.001,
            ThresholdMaxStep: 0.001,
            redStep: 1,
            greenStep: 1,
            blueStep: 1,
            wStep: 0.05,
            hStep: 0.05,
            xStep: 10,
            yStep: 10,
            zStep: 10,
            rxStep: 0.1,
            ryStep: 0.1,
            rzStep: 0.1
        };

        let btStatusControls = document.getElementById('obtainStatusAndSetSizeControls');
        btStatusControls.addEventListener('click', function () {

            let entities = window.NAF.connection.entities.entities;
            let panelsSizeControlsDiv = document.getElementById('panelsSizeControlsDiv');

            /* Clear Panels Size  Controls */
            panelsSizeControlsDiv.replaceChildren([]);

            /* DestroyGui */
            try {
                console.log("destroying");
                if (btStatusControls.gui) {
                    btStatusControls.gui.destroy();
                }
            }
            catch (e) {
                console.log(e);
            }

            btStatusControls.gui = new dat.GUI({ width: 200 });

            let elementsDatGui = [];
            let videoUserGui = [];

            let nActor = 0;

            if (entities) {

                /* Canvas Size Controls */
                let panel = {};
                for (let e in entities) {

                    let h = window.NAF.connection.entities.entities[e].childNodes[1].getAttribute('height');
                    if (h) {
                        nActor++;

                        /*  Thresholds Green */
                        videoUserGui[e] = btStatusControls.gui.addFolder(e);

                        /*  Panels  */
                        panel[e] = window.NAF.connection.entities.entities[e].childNodes[0].id === "videoPlaneGreen" ?
                            window.NAF.connection.entities.entities[e].childNodes[0] :
                            window.NAF.connection.entities.entities[e].childNodes[1];

                        elementsDatGui[e] = [];
                        for (let a in api_pattern_single) {

                            let L = a + "Low";
                            let H = a + "High";
                            let S = a + "Step";

                            elementsDatGui[e][a] = videoUserGui[e].add(api_pattern_single, a, api_pattern_singleMin[L], api_pattern_singleMax[H], api_pattern_singleStep[S]);

                            if (a[0] === 'w'
                                || a[0] === 'h'
                                || a[0] === 'x'
                                || a[0] === 'y'
                                || a[0] === 'z'
                                || a.substring(0, 2) === 'rx'
                                || a.substring(0, 2) === 'ry'
                                || a.substring(0, 2) === 'rz') {

                                elementsDatGui[e][a].panelaki = panel[e];
                                elementsDatGui[e][a].domElement.pName = e;

                                switch (a[0]) {
                                    case 'w':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[5].panelaki;
                                            p.setAttribute('width', api_pattern_single[this.property]);
                                        });
                                        break;
                                    case 'h':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[6].panelaki;
                                            p.setAttribute('height', api_pattern_single[this.property]);
                                        });
                                        break;
                                    case 'x':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[7].panelaki;
                                            p.getAttribute('position').x = api_pattern_single[this.property] / 10000;
                                        });
                                        break;
                                    case 'y':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[8].panelaki;
                                            p.getAttribute('position').y = api_pattern_single[this.property] / 10000;
                                        });
                                        break;
                                    case 'z':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[9].panelaki;
                                            p.getAttribute('position').z = api_pattern_single[this.property] / 10000;
                                        });
                                        break;


                                }

                                switch (a.substring(0, 2)) {

                                    case 'rx':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[10].panelaki;
                                            let xStr = api_pattern_single[this.property];
                                            let yStr = p.getAttribute('rotation').y;
                                            let zStr = p.getAttribute('rotation').z;
                                            p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                        });
                                        break;

                                    case 'ry':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[11].panelaki;
                                            let xStr = p.getAttribute('rotation').x;
                                            let yStr = api_pattern_single[this.property];
                                            let zStr = p.getAttribute('rotation').z;
                                            p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                        });
                                        break;

                                    case 'rz':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[12].panelaki;
                                            let xStr = p.getAttribute('rotation').x;
                                            let yStr = p.getAttribute('rotation').y;
                                            let zStr = api_pattern_single[this.property];
                                            p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                        });
                                        break;
                                }

                            } else {
                                elementsDatGui[e][a].onChange(function () {
                                    let domAffected = document.getElementsByClassName("videoPlaneGreenClass")[elementsDatGui[e][a].nActor];
                                    domAffected.setAttribute("networked-video-source", this.property, api_pattern_single[this.property]);
                                });
                            }
                            elementsDatGui[e][a].nActor = nActor - 1;
                        }
                    }
                }
            }
        });

        /* Called by Networked-Aframe when connected to server */
        function onConnect() {

            let OnConnectDate = new Date();

            const screenBtnEle = document.getElementById('screen-btn-sendscreen');
            screenBtnEle.addEventListener('click', function () {
                navigator.mediaDevices.getDisplayMedia({
                    preferCurrentTab: true,
                    selfBrowserSurface: 'include',
                    audio: true
                }).then((stream) => {
                    NAF.connection.adapter.addLocalMediaStream(stream, "screen");
                });
            });
        }

        let record_button = document.getElementById('start-recording-btn');
        let video_preview = document.getElementById('video-preview');

        let download_button = document.getElementById('download-recording-btn');
        download_button.style.visibility = 'hidden';
        let upload_button = document.getElementById('upload-recording-btn');
        let capture_label = document.getElementById('captured-video-label');
        let recording = document.getElementById('recording');

        function startRecording(stream) {

            let recorder = new MediaRecorder(stream);
            let data = [];

            recorder.ondataavailable = event => data.push(event.data);
            recorder.start();

            let stopped = new Promise((resolve, reject) => {
                recorder.onstop = resolve;
                recorder.onerror = event => reject(event.name);
            });

            return Promise.all([
                stopped
            ]).then(() => data);
        }

        function stopRecording(stream) {
            stream.getTracks().forEach(track => track.stop());
            record_button.disabled = false;
            download_button.style.visibility = 'visible';
            upload_button.disabled = false;
        }

        let recordedBlob;

        record_button.addEventListener("click", function () {

            capture_label.innerHTML = '';

            navigator.mediaDevices.getDisplayMedia({
                preferCurrentTab: true,
                selfBrowserSurface: 'include',
                systemAudio: 'include',
                video: {
                    cursor: 'never'
                },
                audio: true
            }).then(stream => {

                record_button.disabled = true;
                download_button.style.visibility = 'hidden';

                video_preview.style.display = 'block';
                video_preview.srcObject = stream;
                download_button.href = stream;
                video_preview.captureStream = video_preview.captureStream || video_preview.mozCaptureStream;

                stream.getVideoTracks()[0].onended = function () {
                    video_preview.style.display = 'none';
                    stopRecording(video_preview.srcObject);
                };

                return new Promise(resolve => video_preview.onplaying = resolve);
            }).then(() => startRecording(video_preview.captureStream()))
                .then(recordedChunks => {

                    recordedBlob = new Blob(recordedChunks, { type: "video/webm" });
                    recording.src = URL.createObjectURL(recordedBlob);
                    download_button.style.visibility = 'visible';
                    download_button.href = recording.src;
                    download_button.download = "RecordedVideo.webm";

                    upload_button.href = recording.src;
                    capture_label.innerHTML = "Recorded " + formatBytes(recordedBlob.size) + " of " +
                        recordedBlob.type + " media.";

                });
        }, false);

        upload_button.addEventListener("click", function () {

            upload_button.disabled = true;

            const mv_url = document.getElementById('node-url-input').value;
            const mv_token = document.getElementById('node-token-input').value;
            const mv_project_id = document.getElementById('mv-project-id-input').value;

            const video_file = new File([recordedBlob], 'vrodos-' + recordedBlob.size + '.webm', {
                type: recordedBlob.type,
            });

            let formData = new FormData();
            formData.append('file', video_file);

            fetch(mv_url + '/dam/assets?description=' + 'Recorded video from VROdos' + '&externalTool=VRodos', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${mv_token}`
                },
                body: formData
            }).then(function (response) {
                if (response.ok) {
                    return response.json();
                } else {
                    upload_button.disabled = false;
                    alert("There has been a problem uploading your video to MediaVerse platform");
                }
            }).then(function (data) {

                fetch(mv_url + '/dam/project/' + mv_project_id + '/projectOutput', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${mv_token}`
                    },
                    body: JSON.stringify({
                        "projectOutput": [data.key]
                    })
                }).then(function (response) {
                    upload_button.disabled = false;
                    if (response.ok) {
                        alert('The video has been successfully uploaded to MediaVerse!');
                    } else {
                        alert("There has been a problem uploading your video to MediaVerse platform");
                        console.log(response.json());
                    }
                })
            });
        });

        /* x button show clacket. key code 88 */
        document.addEventListener('keydown', function (e) {
            if (e.keyCode === 88) {
                document.getElementById('actionsDiv').style.display = 'block';

                if (document.getElementsByClassName('dg ac')[0]) {
                    document.getElementsByClassName('dg ac')[0].style.display = 'block';
                }

                if (document.cancelFullScreen) {
                    document.cancelFullScreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitCancelFullScreen) {
                    document.webkitCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        });

        /* Make full screen and hide controls */
        let director_controls = document.getElementById("toggle_controls");
        director_controls.onclick = function () {

            document.getElementById('actionsDiv').style.display = 'none';

            if (document.getElementsByClassName('dg ac')[0]) {
                document.getElementsByClassName('dg ac')[0].style.display = 'none';
            }

            let elem = document.body;

            if (elem.requestFullScreen) {
                elem.requestFullScreen();
            } else if (elem.mozRequestFullScreen) {
                elem.mozRequestFullScreen();
            } else if (elem.webkitRequestFullScreen) {
                elem.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            }
        };

        let formatBytes = (bytes, decimals = 2) => {
            if (!+bytes) return '0 Bytes'

            const k = 1024
            const dm = decimals < 0 ? 0 : decimals
            const sizes = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']

            const i = Math.floor(Math.log(bytes) / Math.log(k))

            return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`
        };

        window.ntExample = {
            randomColor: () => {
                return '#' + new THREE.Color(Math.random(), Math.random(), Math.random()).getHexString();
            }
        };

    </script>

    <!-- This will change the glb materials -->
    <!-- <script src="js/glb_material_changer.js"></script> -->

    <script src="js/components/chat_component.js"></script>
</body>

</html>
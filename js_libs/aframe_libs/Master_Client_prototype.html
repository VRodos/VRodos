<!DOCTYPE html>
<html lang="el">

<head>
    <meta charset="utf-8" />
    <title>ŒñœâŒΩœÑŒ±ŒΩŒÆ Œ†Œ±œÅŒ¨œÉœÑŒ±œÉŒ∑</title>
    <meta name="description" content="Dev Example ‚Äî Networked-Aframe with Green Screen effect" />

    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <script src="js/aframe/1.3.0/aframe.min.js"></script>
    <script src="js/socketio/2.3.0/socket.io.slim.js"></script>
    <script src="js/datgui/0.7.7/dat.gui.min.js"></script>

    <script src="../easyrtc/easyrtc.js"></script>
    <script src="../dist/networked-aframe.js"></script>

    <script src="js/a-water_alphamask_master.js"></script>
    <script src="js/sunsky/3.0.3/aframe-sun-sky.min.js"></script>
    <script src="js/randomizer/3.0.1/aframe-randomizer-components.min.js"></script>

    <script src="js/particles/aframe-particle-system-component.min.js"></script>
    <script src="js/spawn-in-circle.component.js"></script>

    <script src="js/highlight_img.js"></script>
    <script src="js/indicators_aframe.js"></script>



    <script src="js/img_panel.js"></script>



    <link rel="stylesheet" type="text/css" href="css/adv-screen.css" />
</head>

<body id="master-client-body">

    <script>
        AFRAME.registerComponent('clear-frustum-culling', {
            init: function () {
                let el = this.el;
                el.addEventListener("model-loaded", e => {
                    let mesh = el.getObject3D('mesh');
                    if (!mesh) { return; }
                    mesh.traverse(function (node) {
                        if (node.isMesh) {
                            node.frustumCulled = false;
                        }
                    });
                });
            }
        });



        AFRAME.registerComponent("rotate", {
            schema: {
                renderingOrderArg: { type: 'string', default: '0 0 0' }
            },
            init: function () {

                //this.el.components['look-controls'].yawObject.rotation.set(0, 90, 0);
                var pos = document.querySelector('#cam').getAttribute('position');
                console.log(pos);
                document.getElementById('cam').setAttribute("rotation", this.data);
                var cameraEl = document.querySelector('#cam');
                var worldPos = new THREE.Vector3();
                worldPos.setFromMatrixPosition(cameraEl.object3D.matrixWorld);
                console.log(worldPos.x);
                //this.el.components['look-controls'].yawObject.rotation.y += 90;
                //el.removeAttribute('look-controls')
                //this.el.components["look-controls"].pitchObject.rotation.x = 0.7
                //this.el.components["look-controls"].yawObject.rotation.y = 0.8
            }

        });

        AFRAME.registerComponent('static-mask-me', {
            init: function () {
                let el = this.el;
                // el.addEventListener("model-loaded", e => {
                const maskMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: false,
                    colorWrite: false,
                });
                maskMaterial.needsUpdate = true;
                let mesh = el.getObject3D('mesh');
                if (!mesh) {
                    return;
                }
                mesh.traverse(node => {
                    if (!node.isMesh) {
                        return;
                    }
                    node.material = maskMaterial;
                    node.renderOrder = 999;
                });
                //  });
            },
            tick: null
        });

        AFRAME.registerComponent('render-order-change', {
            schema: {
                renderingOrderArg: { type: 'string', default: '2000' }
            },
            init: function () {
                let el = this.el;
                // el.addEventListener("model-loaded", e => {
                let mesh = el.getObject3D('mesh');
                if (!mesh) {
                    return;
                }
                mesh.traverse(node => {
                    if (!node.isMesh) {
                        return;
                    }
                    node.renderOrder = this.data.renderingOrderArg;

                });
                //  });
            },
            tick: null
        });
        AFRAME.registerComponent('video-controls', {
            schema: { type: "string", default: "default value" },
            init: function () {
                let data = this.data;
                let video_id = "#video_" + data;
                let video = document.querySelector(video_id);

                let video_display_id = "#video-display_" + data;
                let video_border_id = "#video-border_" + data;

                let videoDisplay = document.querySelector(video_display_id);
                let videoBorder = document.querySelector(video_border_id);
                let videoMesh = videoDisplay.getObject3D("mesh");
                let borderMesh = videoBorder.getObject3D("mesh");

                videoBorder.addEventListener("mousedown", function (event) {
                    if (video.paused) {
                        video.play();
                        //borderMesh.material.color.set("#004400");
                    }
                    else {
                        video.pause();
                        //borderMesh.material.color.set("#440000");
                    }
                });
            }

        });
        AFRAME.registerComponent('door-listener', {
            schema: { type: "string", default: "default value" },
            init: function () {
                this.el.addEventListener("click", e => {
                    //console.log();
                    window.location.replace(this.data);
                });
            }
        });

        AFRAME.registerComponent("overlay", {
            dependencies: ['material'],
            init: function () {
                this.el.sceneEl.renderer.sortObjects = true;
                this.el.object3D.renderOrder = 100;
                this.el.components.material.material.depthTest = false;
            }
        })

        AFRAME.registerComponent('image-display', {
            schema: {
                id_img: { default: "default value" },
                main_img: { default: "default value" },
                esc_img: { default: "default value" }
            },
            init: function () {



                let click_event = this.el.addEventListener("click", e => {
                    this.el.emit("img_open");
                    let cam = document.getElementById("player");
                    //this.el.emit("event1");
                    /*

                    var entity_main = document.createElement('a-plane');
                    var title_main = document.createElement('a-text');

                    var desc_main = document.createElement('a-text');
                    */

                    let entitycheck = document.getElementById(this.data.id_img);
                    if (!entitycheck) {
                        /*

                        entity_main.setAttribute("src", '#' + this.data.main_img);
                        entity_main.setAttribute("id", this.data.id_img);
                        entity_main.setAttribute("height", "8");
                        entity_main.setAttribute("width", "8");
                        entity_main.setAttribute("position", "0  2  -10");
                        entity_main.setAttribute("material", "shader: flat");
                        entity_main.setAttribute("overlay", "");

                        title_main.setAttribute("value", "Title of the image");
                        title_main.setAttribute("position", "-3  6  -9");
                        title_main.setAttribute("color", "black");
                        title_main.setAttribute("transparent", "true");
                        title_main.setAttribute("anchor", "left");
                        title_main.setAttribute("overlay", "");
                        title_main.setAttribute("width", "8");

                        desc_main.setAttribute("value", "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum lobortis, odio in vulputate interdum, sapien neque interdum mi, et suscipit elit sem non risus. Sed rutrum augue sed lectus convallis vehicula. Maecenas orci neque, rutrum in blandit eget, ultricies sit amet turpis. Curabitur maximus purus vel auctor faucibus.");
                        desc_main.setAttribute("position", "-3  0  -9");
                        desc_main.setAttribute("color", "white");
                        desc_main.setAttribute("transparent", "true");
                        desc_main.setAttribute("anchor", "left");
                        desc_main.setAttribute("overlay", "");
                        desc_main.setAttribute("width", "6");
                        desc_main.setAttribute("wrapCount", "40");



                        cam.appendChild(entity_main);
                        cam.appendChild(title_main);
                        cam.appendChild(desc_main);
                        */

                        var entity_esc = document.createElement('a-plane');

                        entity_esc.setAttribute("src", '#' + this.data.esc_img);

                        // Set the position of the box to the click intersection.
                        entity_esc.setAttribute("height", "1");
                        entity_esc.setAttribute("width", "1");
                        entity_esc.setAttribute("position", "3  7 -9");
                        entity_esc.setAttribute("material", "shader: flat");
                        entity_esc.setAttribute("overlay", "");
                        entity_esc.addEventListener("click", e => { cam.removeChild(entity_main); cam.removeChild(entity_esc); cam.removeChild(title_main); cam.removeChild(desc_main); });

                        // Append the box element to the scene.
                        cam.appendChild(entity_esc);
                    }
                });

                this.el.addEventListener("img_open", e => {
                    //this.el.object3D.visible = false;

                    //this.el.emit("imageClick");
                    console.log("Clicked");
                    removeEventListener('click', click_event, false);
                    //this.el.setAttribute("src", "#search");
                    //window.location.replace(this.data);
                });
                this.el.addEventListener("animationcomplete", e => {
                    //this.el.object3D.visible = false;

                    //this.el.emit("event2");
                    //console.log(this.el.animation);
                    console.log("Animation completed");
                    //this.el.setAttribute("src", "#search");
                    //this.el.setAttribute("src", "#search");
                    //window.location.replace(this.data);
                });
            }
        });
    </script>

    <div>
        <div class="wrapperVideoElement" style="visibility: hidden">
            <video id="video-preview" width="300" height="200" autoplay muted></video>
            <video id="recording" hidden></video>
        </div>

        <div class="actionsDirector" name="actionsDiv" id="actionsDiv">
            <div id="toggle_controls">Close <span style="color: white">("x" button to show again)</span></div>
            <div id="directorline" style=""></div>


            <div class="wrapperControlElement">
                <label for="roomNameShow" title="Name of Room">&#127917;</label>
                <span id="roomNameShow">roomname</span>
            </div>

            <div class="wrapperControlElement">
                <label for="occupantsNumberShow" title="Number of actors">&#128101;</label>
                <span id="occupantsNumberShow"></span>
            </div>

            <div class="wrapperControlElement">
                <button id="obtainStatusAndSetSizeControls" class="buttonMultiplaying"
                    title="Obtain status and control green screens">
                    &#128260; &#9989;
                </button>
            </div>

            <div class="wrapperControlElement">
                <button id="screen-btn-sendscreen" class="buttonMultiplaying" title="Send scene stream back to actors">
                    &#127909; &#9654; &#128101;
                </button>
            </div>

            <div class="wrapperControlLineElement">
                <button id="start-recording-btn" class="buttonStartRecord" title="Start capturing video">
                    ‚ö™Ô∏è
                </button>

                <button id="stop-recording-btn" class="buttonStopRecord" title="Save capture" disabled>
                    ‚óºÔ∏è
                </button>

                <a id="download-recording-btn" class="buttonDownloadRecording" title="Download video" disabled>
                    üíæÔ∏èÔ∏è
                </a>

                <button id="upload-recording-btn" class="buttonUploadRecording" style="visibility: hidden"
                    title="Upload Recording to MediaVerse" disabled>
                    ‚¨ÜÔ∏èÔ∏èÔ∏è
                </button>
            </div>
            <div class="wrapperControlElement">
                <span id="captured-video-label"></span>
            </div>
            <div class="wrapperControlElement">
                <label for="positionShow" title="Camera Position">&#127909;</label>
                <span id="positionShow"></span>
            </div>

            <div id="panelsSizeControlsDiv"></div>
            <input id="node-url-input" hidden disabled />
            <input id="node-token-input" hidden disabled />
            <input id="mv-project-id-input" hidden disabled />
        </div>
    </div>


    <a-scene id="aframe-scene-container" fog="type: linear; color: #AAB; far: 230; near: 0"
        renderer="antialias: true; sortObjects: true; toneMapping: ACESFilmic" background="color: #000000"
        vr-mode-ui="enabled: false" networked-scene="
        room: roomname;
        debug: true;
        audio: true;
        adapter: easyrtc;
       " background="color: #212" environment cursor="rayOrigin: mouse; fuse: false">

        <a-assets>
            <!-- Avatar Template -->
            <template id="avatar-template">
                <a-entity class="avatar" networked-audio-source>

                    <a-plane id="videoPlaneGreen" class="videoPlaneGreenClass" color="#FFF" width="1" height="0.75"
                        position="0 0.6 -0.15" material="side: double"
                        networked-video-source="useGreenScreen: true; greenThreshold: 0.04; streamName: video"
                        render-order-change="2000">
                    </a-plane>

                    <a-plane id="screenPlane" color="#FFF" width="0" height="0" position="0 0.6 -0.15"
                        material="side: double" networked-video-source="streamName:screen">
                    </a-plane>
                </a-entity>
            </template>




            <a-mixin id="frame" geometry="primitive: plane; width: 0.5783552; height: 0.8192"
                material="color: white; shader: flat"
                animation__scale="property: scale; to: 1.2 1.2 1.2; dur: 200;  startEvents: tmp1"
                animation__scale_reverse="property: scale; to: 1 1 1; dur: 200; startEvents: tmp2"></a-mixin>
            <a-mixin id="poster" geometry="primitive: plane; width: 0.544768; height: 0.786432"
                material="color: white; shader: flat" material="shader: flat" position="0 0 0.005"></a-mixin>
            <a-mixin id="poiImage" geometry="primitive: plane; width: 1.5; height: 0.81"
                material="shader: flat; transparent: true" position="0 0.495 0.002"></a-mixin>
            <a-mixin id="poiImageFull" geometry="primitive: plane; width: 1.5; height: 1.5"
                material="shader: flat; transparent: true" position="0 0 0.002"></a-mixin>
            <a-mixin id="poiEsc" geometry="primitive: plane; width: 0.1; height: 0.2"
                material="shader: flat; transparent: true" position="1 0.8 0.002"></a-mixin>
        </a-assets>

        <!--
    <a-plane id="video-border" width="17" height="10" position="0 5 -20" color="#440000" video-controls>
        <a-video id="video-display" width="16" height="9" position="0 0 0.1" src="#video">
        </a-video>
    </a-plane>
    -->
        <a-plane outline="color:green ; pulse:false"></a-plane>
        <a-entity id="background" position="0 0 0" geometry="primitive: sphere; radius: 2.0"
            material="color: red; side: back; shader: flat" scale="0.001 0.001 0.001" visible="false"
            class="raycastable">
        </a-entity>
        <!-- Pawn -->
        <a-entity id="player" visible="false" networked="template:#avatar-template;attachTemplateToLocal:false;" rotate
            position="0 -6 0" rotation="0 0 0" wasd-controls="fly: true; acceleration:5" show-position
            look-controls="pointerLockEnabled: false;">

            <a-sphere class="head" visible="false" random-color>
            </a-sphere>

            <a-entity active="true" transparency="true" visible="false" camera="near: 0.1; far: 7000.0;" id="cam"
                position="0 0.6 0" rotation="0 0 0">
            </a-entity>
            <!--<a-entity id="fadeBackground" geometry="primitive: sphere; radius: 2.5"
                material="color: black; side: back; shader: flat; transparent: true; opacity: 0.6" visible="false">
            </a-entity>-->
        </a-entity>



    </a-scene>


    <script>

        AFRAME.registerComponent('show-position', {
            init: function () {
                this.positionShow = document.getElementById("positionShow");
                this.occupantsNumberShow = document.getElementById("occupantsNumberShow");
            },
            tick: function (time, timeDelta) {
                let p = this.el.getAttribute('position');
                this.positionShow.innerHTML = Math.round(p.x * 100) / 100 + ", " + Math.round(p.y * 100) / 100 + ", " + Math.round(p.z * 100) / 100;

                let occupants = window.easyrtc.getRoomOccupantsAsMap(window.NAF.room);
                if (occupants) {
                    this.occupantsNumberShow.innerHTML = Object.keys(occupants).length;
                }
            }
        });

        const api_pattern_single = {
            ThresholdMin: 0.106,
            ThresholdMax: 0.13,
            red: 48, green: 146, blue: 89,
            w: 1, h: 0.75,
            x: 0, y: 0, z: 0,
            rx: 0, ry: 0, rz: 0
        };

        const api_pattern_singleMin = {
            ThresholdMinLow: 0,
            ThresholdMaxLow: 0,
            redLow: 0,
            greenLow: 0,
            blueLow: 0,
            wLow: 0.1,
            hLow: 0.1,
            xLow: -100000,
            yLow: -100000,
            zLow: -100000,
            rxLow: -100,
            ryLow: -100,
            rzLow: -100
        };
        const api_pattern_singleMax = {
            ThresholdMinHigh: 0.4,
            ThresholdMaxHigh: 0.4,
            redHigh: 255,
            greenHigh: 255,
            blueHigh: 255,
            wHigh: 5,
            hHigh: 5,
            xHigh: 100000,
            yHigh: 100000,
            zHigh: 100000,
            rxHigh: 100,
            ryHigh: 100,
            rzHigh: 100
        };
        const api_pattern_singleStep = {
            ThresholdMinStep: 0.001,
            ThresholdMaxStep: 0.001,
            redStep: 1,
            greenStep: 1,
            blueStep: 1,
            wStep: 0.05,
            hStep: 0.05,
            xStep: 10,
            yStep: 10,
            zStep: 10,
            rxStep: 0.1,
            ryStep: 0.1,
            rzStep: 0.1
        };

        let btStatusControls = document.getElementById('obtainStatusAndSetSizeControls');
        btStatusControls.addEventListener('click', function () {

            let entities = window.NAF.connection.entities.entities;
            let panelsSizeControlsDiv = document.getElementById('panelsSizeControlsDiv');

            /* Clear Panels Size  Controls */
            panelsSizeControlsDiv.replaceChildren([]);

            /* DestroyGui */
            try {
                console.log("destroying");
                if (btStatusControls.gui) {
                    btStatusControls.gui.destroy();
                }
            }
            catch (e) {
                console.log(e);
            }

            btStatusControls.gui = new dat.GUI({ width: 200 });

            let elementsDatGui = [];
            let videoUserGui = [];

            let nActor = 0;

            if (entities) {

                /* Canvas Size Controls */
                let panel = {};
                for (let e in entities) {

                    let h = window.NAF.connection.entities.entities[e].childNodes[1].getAttribute('height');
                    if (h) {
                        nActor++;

                        /*  Thresholds Green */
                        videoUserGui[e] = btStatusControls.gui.addFolder(e);

                        /*  Panels  */
                        panel[e] = window.NAF.connection.entities.entities[e].childNodes[0].id === "videoPlaneGreen" ?
                            window.NAF.connection.entities.entities[e].childNodes[0] :
                            window.NAF.connection.entities.entities[e].childNodes[1];

                        elementsDatGui[e] = [];
                        for (let a in api_pattern_single) {

                            let L = a + "Low";
                            let H = a + "High";
                            let S = a + "Step";

                            elementsDatGui[e][a] = videoUserGui[e].add(api_pattern_single, a, api_pattern_singleMin[L], api_pattern_singleMax[H], api_pattern_singleStep[S]);

                            if (a[0] === 'w'
                                || a[0] === 'h'
                                || a[0] === 'x'
                                || a[0] === 'y'
                                || a[0] === 'z'
                                || a.substring(0, 2) === 'rx'
                                || a.substring(0, 2) === 'ry'
                                || a.substring(0, 2) === 'rz') {

                                elementsDatGui[e][a].panelaki = panel[e];
                                elementsDatGui[e][a].domElement.pName = e;

                                switch (a[0]) {
                                    case 'w':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[5].panelaki;
                                            p.setAttribute('width', api_pattern_single[this.property]);
                                        });
                                        break;
                                    case 'h':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[6].panelaki;
                                            p.setAttribute('height', api_pattern_single[this.property]);
                                        });
                                        break;
                                    case 'x':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[7].panelaki;
                                            p.getAttribute('position').x = api_pattern_single[this.property] / 10000;
                                        });
                                        break;
                                    case 'y':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[8].panelaki;
                                            p.getAttribute('position').y = api_pattern_single[this.property] / 10000;
                                        });
                                        break;
                                    case 'z':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[9].panelaki;
                                            p.getAttribute('position').z = api_pattern_single[this.property] / 10000;
                                        });
                                        break;


                                }

                                switch (a.substring(0, 2)) {

                                    case 'rx':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[10].panelaki;
                                            let xStr = api_pattern_single[this.property];
                                            let yStr = p.getAttribute('rotation').y;
                                            let zStr = p.getAttribute('rotation').z;
                                            p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                        });
                                        break;

                                    case 'ry':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[11].panelaki;
                                            let xStr = p.getAttribute('rotation').x;
                                            let yStr = api_pattern_single[this.property];
                                            let zStr = p.getAttribute('rotation').z;
                                            p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                        });
                                        break;

                                    case 'rz':
                                        elementsDatGui[e][a].onChange(function () {
                                            let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[12].panelaki;
                                            let xStr = p.getAttribute('rotation').x;
                                            let yStr = p.getAttribute('rotation').y;
                                            let zStr = api_pattern_single[this.property];
                                            p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                        });
                                        break;
                                }

                            } else {
                                elementsDatGui[e][a].onChange(function () {
                                    let domAffected = document.getElementsByClassName("videoPlaneGreenClass")[elementsDatGui[e][a].nActor];
                                    domAffected.setAttribute("networked-video-source", this.property, api_pattern_single[this.property]);
                                });
                            }
                            elementsDatGui[e][a].nActor = nActor - 1;
                        }
                    }
                }
            }
        });

        /* Define custom schema for syncing avatar color, set by random-color */
        NAF.schemas.add({
            template: '#avatar-template',
            components: [
                'position',
                'rotation'
            ]
        });

        /* Called by Networked-Aframe when connected to server */
        function onConnect() {
            console.log("onConnect", new Date());

            const screenBtnEle = document.getElementById('screen-btn-sendscreen');
            screenBtnEle.addEventListener('click', function () {
                navigator.mediaDevices.getDisplayMedia({
                    preferCurrentTab: true,
                    selfBrowserSurface: 'include',
                    audio: true
                }).then((stream) => {
                    NAF.connection.adapter.addLocalMediaStream(stream, "screen");
                });
            });
        }

        let record_button = document.getElementById('start-recording-btn');
        let video_preview = document.getElementById('video-preview');
        let stop_button = document.getElementById('stop-recording-btn');
        let download_button = document.getElementById('download-recording-btn');
        let upload_button = document.getElementById('upload-recording-btn');
        let capture_label = document.getElementById('captured-video-label');
        let recording = document.getElementById('recording');

        function startRecording(stream) {

            let recorder = new MediaRecorder(stream);
            let data = [];

            recorder.ondataavailable = event => data.push(event.data);
            recorder.start();

            let stopped = new Promise((resolve, reject) => {
                recorder.onstop = resolve;
                recorder.onerror = event => reject(event.name);
            });

            return Promise.all([
                stopped
            ]).then(() => data);
        }

        function stopRecording(stream) {
            stream.getTracks().forEach(track => track.stop());
            record_button.disabled = false;
            stop_button.disabled = true;
            download_button.disabled = false;
            upload_button.disabled = false;
        }

        let recordedBlob;

        record_button.addEventListener("click", function () {

            capture_label.innerHTML = '';

            navigator.mediaDevices.getDisplayMedia({
                preferCurrentTab: true,
                selfBrowserSurface: 'include',
                systemAudio: 'include',
                video: {
                    cursor: 'never'
                },
                audio: true
            }).then(stream => {

                record_button.disabled = true;
                stop_button.disabled = false;

                video_preview.style.display = 'block';
                video_preview.srcObject = stream;
                download_button.href = stream;
                video_preview.captureStream = video_preview.captureStream || video_preview.mozCaptureStream;

                stream.getVideoTracks()[0].onended = function () {
                    video_preview.style.display = 'none';
                    stopRecording(video_preview.srcObject);
                };

                return new Promise(resolve => video_preview.onplaying = resolve);
            }).then(() => startRecording(video_preview.captureStream()))
                .then(recordedChunks => {

                    recordedBlob = new Blob(recordedChunks, { type: "video/webm" });
                    recording.src = URL.createObjectURL(recordedBlob);
                    download_button.href = recording.src;
                    download_button.download = "RecordedVideo.webm";

                    upload_button.href = recording.src;
                    capture_label.innerHTML = "Recorded " + formatBytes(recordedBlob.size) + " of " +
                        recordedBlob.type + " media.";

                });
        }, false);

        stop_button.addEventListener("click", function () {
            stopRecording(video_preview.srcObject);
        }, false);

        upload_button.addEventListener("click", function () {

            upload_button.disabled = true;

            const mv_url = document.getElementById('node-url-input').value;
            const mv_token = document.getElementById('node-token-input').value;
            const mv_project_id = document.getElementById('mv-project-id-input').value;

            const video_file = new File([recordedBlob], 'vrodos-' + recordedBlob.size + '.webm', {
                type: recordedBlob.type,
            });

            let formData = new FormData();
            formData.append('file', video_file);

            fetch(mv_url + '/dam/assets?description=' + 'Recorded video from VROdos' + '&externalTool=VRodos', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${mv_token}`
                },
                body: formData
            }).then(function (response) {
                if (response.ok) {
                    return response.json();
                } else {
                    upload_button.disabled = false;
                    alert("There has been a problem uploading your video to MediaVerse platform");
                }
            }).then(function (data) {

                fetch(mv_url + '/dam/project/' + mv_project_id, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${mv_token}`
                    },
                    body: JSON.stringify({
                        "projectOutput": [data.key]
                    })
                }).then(function (response) {
                    upload_button.disabled = false;
                    if (response.ok) {
                        alert('The video has been successfully uploaded to MediaVerse!');
                    } else {
                        alert("There has been a problem uploading your video to MediaVerse platform");
                        console.log(response.json());
                    }
                })
            });
        });

        /* Scale down div when in compile preview */
        (function () {
            if (window.innerWidth < 400) {
                let actionsDiv = document.getElementById("actionsDiv");
                actionsDiv.style.transformOrigin = "0px 200px";
                actionsDiv.style.scale = "0.3";
            }
        })();

        /* x button show clacket. key code 88 */
        document.addEventListener('keydown', function (e) {
            if (e.keyCode === 88) {
                document.getElementById('actionsDiv').style.display = 'block';

                if (document.getElementsByClassName('dg ac')[0]) {
                    document.getElementsByClassName('dg ac')[0].style.display = 'block';
                }

                if (document.cancelFullScreen) {
                    document.cancelFullScreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitCancelFullScreen) {
                    document.webkitCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        });

        /* Make full screen and hide controls */
        let director_controls = document.getElementById("toggle_controls");
        director_controls.onclick = function () {

            document.getElementById('actionsDiv').style.display = 'none';

            if (document.getElementsByClassName('dg ac')[0]) {
                document.getElementsByClassName('dg ac')[0].style.display = 'none';
            }

            let elem = document.body;

            if (elem.requestFullScreen) {
                elem.requestFullScreen();
            } else if (elem.mozRequestFullScreen) {
                elem.mozRequestFullScreen();
            } else if (elem.webkitRequestFullScreen) {
                elem.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            }
        };

        let formatBytes = (bytes, decimals = 2) => {
            if (!+bytes) return '0 Bytes'

            const k = 1024
            const dm = decimals < 0 ? 0 : decimals
            const sizes = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']

            const i = Math.floor(Math.log(bytes) / Math.log(k))

            return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`
        };

    </script>

    <!-- This will change the glb materials -->
    <script src="js/glb_material_changer.js"></script>

</body>

</html>
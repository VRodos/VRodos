<!DOCTYPE html>
<html lang="el">

<head>
    <meta charset="utf-8" />
    <title>Collaborative content creation</title>
    <meta name="description" content="Collaborative content creation" />

    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <script src="js/aframe/1.3.0/aframe.min.js"></script>
    <script src="js/socketio/2.3.0/socket.io.slim.js"></script>
    <script src="js/datgui/0.7.7/dat.gui.min.js"></script>

    <script src="../easyrtc/easyrtc.js"></script>
    <script src="../dist/networked-aframe.js"></script>

    <!--<script src="js/a-water_alphamask_master.js"></script>-->
    <script src="js/sunsky/3.0.3/aframe-sun-sky.min.js"></script>
    <script src="js/randomizer/3.0.1/aframe-randomizer-components.min.js"></script>

    <script src="js/particles/aframe-particle-system-component.min.js"></script>
    <script src="js/spawn-in-circle.component.js"></script>

    <script src="js/highlight_img.js"></script>

    <script src="js/components/poi-image_component.js"></script>
    <script src="js/components/poi-link_component.js"></script>
    <script src="js/components/door_component.js"></script>
    <script src="js/components/video_component.js"></script>

    <!--<script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.0.0/dist/aframe-extras.controls.min.js"></script>-->
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.0.0/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.2/dist/aframe-environment-component.min.js"></script>

    <script src="js/indicators_aframe.js"></script>
    <script src="dist/material-components-web.min.js"></script>



    <link rel="stylesheet" type="text/css" href="css/adv-screen.css" />
    <link rel="stylesheet" type="text/css" href="dist/material-components-web.min.css" />
    <link rel="stylesheet" type="text/css" href="css/material-icons/material-icons.css" />

    <script>

        // Global variable to switch between interfaces for interaction modes.
        let browsingModeVR = false;

        /* PLAYER AVATARS (COLOR AND NAME) */
        // Temporary workaround for template declaration; see issue 167
        NAF.schemas.getComponentsOriginal = NAF.schemas.getComponents;
        NAF.schemas.getComponents = (template) => {
            if (!NAF.schemas.hasTemplate('#avatar-template-expo')) {
                NAF.schemas.add({
                    template: '#avatar-template-expo',
                    components: [
                        'position',
                        'rotation',
                        'player-info'
                    ]
                });
            }
            return NAF.schemas.getComponentsOriginal(template);
        };

        window.ntExample = {
            randomColor: () => {
                return '#' + new THREE.Color(Math.random(), Math.random(), Math.random()).getHexString();
            }
        };

        AFRAME.registerComponent('player-info', {
            // notice that color and name are both listed in the schema; NAF will only keep
            // properties declared in the schema in sync.
            schema: {
                name: { type: 'string', default: 'user-' + Math.round(Math.random() * 10000) },
                color: {
                    type: 'color', // btw: color is just a string under the hood in A-Frame
                    default: window.ntExample.randomColor()
                }
            },

            init: function () {
                this.head = this.el.querySelector('.head');
                this.nametag = this.el.querySelector('.nametag');

                this.ownedByLocalUser = this.el.id === 'cameraA';
                if (this.ownedByLocalUser) {
                    // populate the html overlay with the correct name on init
                    this.nametagInput = document.getElementById('username-overlay');
                    this.nametagInput.value = this.data.name;

                    // add the initial color to the html overlay color picker button
                    document.querySelector('button').style.backgroundColor = this.data.color;
                    document.querySelector('button').style.color = this.data.color;
                }
            },

            // here as an example, not used in current demo. Could build a user list, expanding on this.
            listUsers: function () {
                console.log(
                    'userlist',
                    [...document.querySelectorAll('[player-info]')].map((el) => el.components['player-info'].data.name)
                );
            },

            newRandomColor: function () {
                this.el.setAttribute('player-info', 'color', window.ntExample.randomColor());
            },

            update: function () {
                if (this.head) this.head.setAttribute('material', 'color', this.data.color);
                if (this.nametag) this.nametag.setAttribute('value', this.data.name);
            }
        });

        /* END - PLAYER AVATARS (COLOR AND NAME) */


        /**
         * Basic emissive effect.
         */
        AFRAME.registerComponent('glow', {
            schema: {
                color: {default: '#ffffff', type: 'color'},
                intensity: {default: 1.0},
                id:{default: ''}
            },
            init: function () {
                this.backgroundEl = document.querySelector('#exit_' + this.data.id);
                this.buttonEl = document.querySelector('#button_poi_' + this.data.id);

                this.el.addEventListener('object3dset', function () {
                    this.update();
                }.bind(this));
            },
            update: function () {
                var data = this.data;
                this.el.object3D.traverse(function (node) {
                    if (node.isMesh) {
                        node.material.emissive.copy(new THREE.Color(data.color));
                        node.material.emissiveIntensity = data.intensity;
                    }
                });
            }
        });

        AFRAME.registerComponent('clear-frustum-culling', {
            init: function () {
                let el = this.el;
                el.addEventListener("model-loaded", e => {
                    let mesh = el.getObject3D('mesh');
                    if (!mesh) { return; }
                    mesh.traverse(function (node) {
                        if (node.isMesh) {
                            node.frustumCulled = false;
                        }
                    });
                });
            }
        });

        AFRAME.registerComponent('scene-settings', {
            schema: {
                color:{type: "string", default: "#ffffff"},
                pr_type:{type: "string", default: "default"},
                img_link:{type: "string", default: "no_link"},
                selChoice:{type: "string", default: "0"},
                presChoice:{type: "string", default: "default"},
            },
            init: function () {
                console.log(this.data.presChoice);

                let cam = document.querySelector("#cameraA");

                if (this.data.pr_type !== "vrexpo_games")
                    cam.setAttribute("camera", "fov: 60");
                else{
                    cam.setAttribute("fov", "60");
                    cam.setAttribute("camera", "fov: 60"); //temp based on camera settings

                    // Hide eyes from my avatar on self
                    const parent_avatar = document.getElementById('cameraA');
                    let my_face = parent_avatar.querySelector('.face');
                    my_face.setAttribute("visible", "false");

                }
                let backgroundEl = document.querySelector('#aframe-scene-container');
                this.el.addEventListener("loaded", () => {
                    console.log("Scene Loaded");

                    /*var entity = document.querySelector('[sound]');
                    entity.components.sound.playSound();*/

                });
                if (!this.data.selChoice)
                    this.data.selChoice = "0";
                switch(this.data.selChoice){
                    case "0":
                        backgroundEl.setAttribute("background", "color", "#ffffff");

                        break;
                    case "1":
                        backgroundEl.setAttribute("background", "color", this.data.color);
                        break;
                    case "2":
                        backgroundEl.setAttribute("environment", "preset", this.data.presChoice);
                        //backgroundEl.setAttribute("environment", "ground", "flat");
                        backgroundEl.setAttribute("environment", "playArea", "1.4");

                        break;
                    case "3":

                        let customImgAsset = document.querySelector('#custom_sky');
                        if(customImgAsset.getAttribute("src")){
                            let skyElem = document.createElement('a-sky');
                            skyElem.setAttribute("id", "sky");
                            skyElem.setAttribute("src",  "#custom_sky");
                            backgroundEl.appendChild(skyElem);
                            console.log(customImgAsset.getAttribute("src"));
                        }
                        else{
                            backgroundEl.setAttribute("background", "color", "#ffffff");
                        }


                        break;

                }

                // let backgroundEl = document.querySelector('#aframe-scene-container');
                // backgroundEl.setAttribute("background", "color", this.data.color);
            }
        });


        AFRAME.registerComponent('static-mask-me', {
            init: function () {
                let el = this.el;
                // el.addEventListener("model-loaded", e => {
                const maskMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: false,
                    colorWrite: false,
                });
                maskMaterial.needsUpdate = true;
                let mesh = el.getObject3D('mesh');
                if (!mesh) {
                    return;
                }
                mesh.traverse(node => {
                    if (!node.isMesh) {
                        return;
                    }
                    node.material = maskMaterial;
                    node.renderOrder = 999;
                });
                //  });
            },
            tick: null
        });

        AFRAME.registerComponent('render-order-change', {
            schema: {
                renderingOrderArg: { type: 'string', default: '2000' }
            },
            init: function () {
                let el = this.el;
                // el.addEventListener("model-loaded", e => {
                let mesh = el.getObject3D('mesh');
                if (!mesh) {
                    return;
                }
                mesh.traverse(node => {
                    if (!node.isMesh) {
                        return;
                    }
                    node.renderOrder = this.data.renderingOrderArg;

                });
                //  });
            },
            tick: null
        });


        AFRAME.registerComponent("overlay", {
            dependencies: ['material'],
            init: function () {
                this.el.sceneEl.renderer.sortObjects = true;
                this.el.object3D.renderOrder = 100;
                this.el.components.material.material.depthTest = false;
            }
        })


        AFRAME.registerComponent('left-thumbstick', {
            init: function () {
                var hand = this.el;
                var cameraRig = document.querySelector('#cameraA');

                hand.addEventListener('thumbstickmoved', function (event) {
                    var movementVector = new THREE.Vector3(event.detail.x, 0, event.detail.y);
                    cameraRig.object3D.position.add(movementVector.multiplyScalar(cameraRig.getAttribute('movement-controls').data.speed));
                });
            }
        });

        //document.querySelector('#left-hand').setAttribute('left-thumbstick', '');

        AFRAME.registerComponent('show-position', {
            init: function () {
                this.positionShow = document.getElementById("positionShow");
                this.occupantsNumberShow = document.getElementById("occupantsNumberShow");
            },
            tick: function (time, timeDelta) {
                let p = this.el.getAttribute('position');
                this.positionShow.innerHTML = Math.round(p.x * 100) / 100 + ", " + Math.round(p.y * 100) / 100 + ", " + Math.round(p.z * 100) / 100;

                let occupants = window.easyrtc.getRoomOccupantsAsMap(window.NAF.room);
                if (occupants) {
                    this.occupantsNumberShow.innerHTML = Object.keys(occupants).length;
                }
            }
        });

        AFRAME.registerComponent('custom-movement', {
            init: function () {
                const cameraEl = document.querySelector('a-camera');
                const cameraRig = this.el;

                console.log ("Custom-movement exists");
                console.log (cameraEl);

                this.el.addEventListener('thumbstickmoved', (event) => {
                    const thumbstickX = event.detail.x;
                    const thumbstickY = event.detail.y;

                    // Get camera rotation
                    const rotation = cameraEl.getAttribute('rotation');
                    const angleY = THREE.Math.degToRad(rotation.y);

                    // Calculate movement direction based on camera rotation
                    const direction = new THREE.Vector3(-Math.sin(angleY), 0, -Math.cos(angleY));

                    // Apply movement to the camera rig's position
                    const movementSpeed = 0.1;
                    cameraRig.object3D.translateX(-direction.x * thumbstickY * movementSpeed - direction.z * thumbstickX * movementSpeed);
                    cameraRig.object3D.translateZ(-direction.z * thumbstickY * movementSpeed + direction.x * thumbstickX * movementSpeed);


                    console.log('Camera rotation:', rotation.x, rotation.y, rotation.z);
                });
            }
        });


    </script>

    <style>
        .ChatWrapperStyle {
            position: absolute;
            bottom: 0;
            height: auto;
        }
        .ChatWrapperStyleExpanded {
            position: absolute;
            height: auto;
        }

        .ChatMessagesStyle {
            width: 450px;
            background-color: rgba(0,0,0,.7);
            overflow:auto;
            z-index:100;
            bottom: 0;
            left:0;
            display: flex;
            flex-direction: column-reverse;
            font-family: Arial, Helvetica, sans-serif;
            font-size: 14px;
            color: #ccc;
            text-shadow: 1px 1px 2px black;
        }
        .ChatMessagesStyleNormal {
            height: 200px;
            position: relative;
        }
        .ChatMessagesStyleExpanded {
            height: 100%;
            position: fixed;
        }
        .ChatMessagesStyleMinimized {
            height: 0;
            position: relative;
        }

        .IconButtonStyle {
            background-color: transparent;
            cursor: pointer;
            border: none;
            height: 24px;
            width: 24px;
            margin: 0 auto;
            padding: 0 2px 0 2px;
        }
        .IconButtonStyle i {
            text-shadow: 0 0 3px #fff;
        }
    </style>

</head>

<body id="master-client-body">

<div class="ChatWrapperStyle" id="chat-wrapper-el" style="visibility: hidden">
    <div id="chatControlsOverlay" style="position: relative; top: 0; left:0; z-index:101; height: 30px;">
        <button id="color-changer" onclick="
            let newColor = window.ntExample.randomColor();
             document.getElementById('cameraA').setAttribute('player-info', 'color', newColor);
             document.querySelector('button').style.backgroundColor = newColor;
             document.querySelector('button').style.color = newColor;
        ">‚ñ†</button>
        <input id="username-overlay" maxlength="24" size="15" oninput="document.getElementById('cameraA').setAttribute('player-info', 'name', this.value)" placeholder="Username" />
        <input type="text" id="chatInput" placeholder="Message">
        <button id="send-msg-chat-btn" style="right: 0; cursor: pointer">SEND</button>
        <button id="expand-chat-btn" class="IconButtonStyle" title="Chat Size"><i class="material-icons">unfold_more</i></button>
        <button id="minimize-chat-btn" class="IconButtonStyle" title="Minimize"><i class="material-icons">expand_more</i></button>
    </div>
    <div class="ChatMessagesStyle ChatMessagesStyleNormal" id="chat-messages-wrapper">
        <div id="chat-messages"></div>
    </div>
</div>

<div id="mediaPanel">
    <div class="wrapperVideoElement" style="visibility: hidden">
        <video id="video-preview" width="300" height="200" autoplay muted></video>
        <video id="recording" hidden></video>
    </div>

    <div class="actionsDirector" name="actionsDiv" id="actionsDiv">
        <div id="toggle_controls">Close <span style="color: white">("x" button to show again)</span></div>
        <div id="directorline" style=""></div>


        <div class="wrapperControlElement">
            <label for="roomNameShow" title="Name of Room">&#127917;</label>
            <span id="roomNameShow">roomname</span>
        </div>

        <div class="wrapperControlElement">
            <label for="occupantsNumberShow" title="Number of actors">&#128101;</label>
            <span id="occupantsNumberShow"></span>
        </div>

        <div class="wrapperControlElement">
            <button id="obtainStatusAndSetSizeControls" class="buttonMultiplaying"
                    title="Obtain status and control green screens">
                &#128260; &#9989;
            </button>
        </div>

        <div class="wrapperControlElement" >
            <button id="screen-btn-sendscreen" class="buttonMultiplaying" title="Send scene stream back to actors">
                &#127909; &#9654; &#128101;
            </button>
        </div>

        <div class="wrapperControlLineElement">
            <button id="start-recording-btn" class="buttonStartRecord" title="Start capturing video">
                ‚ö™Ô∏è
            </button>

            <a id="download-recording-btn" class="buttonDownloadRecording" title="Download video" style="visibility: hidden">
                üíæÔ∏èÔ∏è
            </a>

            <button id="upload-recording-btn" class="buttonUploadRecording" style="visibility: hidden;"
                    title="Upload Recording to MediaVerse" disabled>
                ‚¨ÜÔ∏èÔ∏èÔ∏è
            </button>
        </div>
        <div class="wrapperControlElement">
            <span id="captured-video-label"></span>
        </div>
        <div class="wrapperControlElement">
            <label for="positionShow" title="Camera Position">&#127909;</label>
            <span id="positionShow"></span>
        </div>

        <div id="panelsSizeControlsDiv"></div>
        <input id="node-url-input" hidden disabled />
        <input id="node-token-input" hidden disabled />
        <input id="mv-project-id-input" hidden disabled />
    </div>
</div>

<!-- IMG POI Dialog component -->
<aside id="poi-img-dialog" class="mdc-dialog" role="alertdialog" style="z-index: 1000;"
       aria-labelledby="Image POI popup" aria-describedby="Show Image POI details"
       data-mdc-auto-init="MDCDialog">
    <div class="mdc-dialog__surface">
        <header class="mdc-dialog__header">
            <h2 id="poi-img-dialog-title" class="mdc-dialog__header__title"></h2>
        </header>

        <section class="mdc-dialog__body">
            <div class="mdc-layout-grid">
                <div class="mdc-layout-grid__inner">
                    <div class="mdc-layout-grid__cell--span-12">
                        <div style="text-align: center">
                            <img src="" alt="Image POI Image" id="poi-img-dialog-image" style="width: auto; max-width: 100%;max-height: 260px;"/>
                        </div>
                        <div style="text-align: left; overflow-y: auto;  max-height: 300px;">
                            <span  class="mdc-typography--body1" id="poi-img-dialog-description"></span>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <footer class="mdc-dialog__footer">
            <a class="mdc-button mdc-button--primary mdc-dialog__footer__button mdc-dialog__footer__button--accept mdc-button--raised" >OK</a>
        </footer>
    </div>
    <div class="mdc-dialog__backdrop"></div>
</aside>

<aside id="video-controls-dialog" class="mdc-dialog" role="alertdialog" style="z-index: 1000;"
       aria-labelledby="Video controls popup" aria-describedby="Show Video controls">
    <div class="mdc-dialog__surface">

        <video controls controlsList="nodownload" id="video-panel-video" height="100%" width="100%" >
            Your browser does not support video.
        </video>

        <footer class="mdc-dialog__footer">
            <a class="mdc-button mdc-button--primary mdc-dialog__footer__button mdc-dialog__footer__button--cancel mdc-button--raised">Close</a>
            <a class="mdc-button mdc-button--primary mdc-dialog__footer__button mdc-dialog__footer__button--accept mdc-button--raised" style="display: none;" tabIndex="0">OK</a>
        </footer>
    </div>
    <div class="mdc-dialog__backdrop"></div>
</aside>


<a-scene  id="aframe-scene-container"
          fog="type: linear; color: #AAB; far: 230; near: 0"
          renderer="antialias: true;
            sortObjects: true;
            toneMapping: ACESFilmic;
            precision: high;"
          oculus-go-controls-enabled
          vr-mode-ui="enabled: true"
          loading-screen="dotsColor: gray; backgroundColor: black"
          networked-scene="
            room: roomname;
            debug: true;
            audio: true;
            adapter: easyrtc;
            connectOnLoad: true;
       ">
    <!--environment="ground:none"-->

    <a-assets id="scene-assets">

        <audio preload="auto" id="underwater-sound" src="../media/sound/underwater.mp3"></audio>

        <!-- Avatar Template -->
        <template id="avatar-template-expo">
            <a-entity class="avatar" player-info>

                <a-sphere class="head" scale="0.2 0.22 0.2"></a-sphere>
                <a-entity class="face" position="0 0.05 0">
                    <a-sphere class="eye" color="white" position="0.06 0.05 -0.16" scale="0.04 0.04 0.04" >
                        <a-sphere class="pupil" color="black" position="0 0 -1" scale="0.2 0.2 0.2" ></a-sphere>
                    </a-sphere>
                    <a-sphere class="eye" color="white" position="-0.06 0.05 -0.16" scale="0.04 0.04 0.04">
                        <a-sphere class="pupil" color="black" position="0 0 -1" scale="0.2 0.2 0.2"></a-sphere>
                    </a-sphere>
                </a-entity>

                <!-- here we add a text component for a nametag; the value will be updated by the player-info component -->
                <a-text
                        class="nametag"
                        value="?"
                        rotation="0 180 0"
                        position=".25 -.35 0"
                        side="double"
                        scale=".5 .5 .5"
                ></a-text>
            </a-entity>
        </template>

        <template id="avatar-template">
            <a-entity class="avatar" networked-audio-source>

                <a-plane id="videoPlaneGreen" class="videoPlaneGreenClass" color="#FFF" width="1" height="0.75"
                         position="0 0.6 -0.15" material="side: double"
                         networked-video-source="useGreenScreen: true; greenThreshold: 0.04; streamName: video"
                         render-order-change="2000">
                </a-plane>

                <a-plane id="screenPlane" color="#FFF" width="0" height="0" position="0 0.6 -0.15"
                         material="side: double" networked-video-source="streamName:screen">
                </a-plane>
            </a-entity>
        </template>

        <a-mixin id="vid_panel" geometry="primitive: plane; width: 0.5783552; height: 0.8192"
                 material="color: black; shader: flat"></a-mixin>
        <a-mixin id="frame" geometry="primitive: plane; width: 0.5783552; height: 0.8192"
                 material="color: white; shader: flat"
                 animation__scale="property: scale; to: 1.2 1.2 1.2; dur: 200;  startEvents: tmp1"
                 animation__scale_reverse="property: scale; to: 1 1 1; dur: 200; startEvents: tmp2"></a-mixin>
        <a-mixin id="poster" geometry="primitive: plane; width: 0.544768; height: 0.786432"
                 material="color: white; shader: flat" material="shader: flat" position="0 0 0.005"></a-mixin>
        <a-mixin id="poiImage" geometry="primitive: plane; width: 1.4; height: 0.8"
                 material="shader: flat;  transparent: true" position="0 0.455 0.002"></a-mixin>
        <a-mixin id="poiImageFull" geometry="primitive: plane; width: 1.4; height: 1.4"
                 material="shader: flat; transparent: true" position="0 0 0.002"></a-mixin>
        <a-mixin id="poiEsc" geometry="primitive: plane; width: 1; height: 1"
                 position="1 0.73 0.002"  material="shader: flat; transparent: true"></a-mixin>
        <a-mixin id="poiImgNext" geometry="primitive: plane; width: 1; height: 1"
                 material="shader: flat; transparent: true" position="1 -0.5 0.002"></a-mixin>
        <a-mixin id="poiImgPrev" geometry="primitive: plane; width: 1; height: 1"
                 material="shader: flat; transparent: true" position="-1 -0.5 0.002"></a-mixin>
        <a-mixin id="poiEscFrame" geometry="primitive: circle; radius: 0.15"
                 material="shader: flat; color: #dfe4ea; depthTest: false; transparent: true" position="1 0.73 0.002"></a-mixin>
        <a-mixin id="poiImgPrevFrame" geometry="primitive: circle; radius: 0.15"
                 material="shader: flat; color: #dfe4ea; depthTest: false; transparent: true" position="-1 -0.5 0.002"></a-mixin>
        <a-mixin id="poiImgNextFrame" geometry="primitive: circle; radius: 0.15"
                 material="shader: flat; color: #dfe4ea; depthTest: false; transparent: true" position=" 1 -0.5 0.002"></a-mixin>
        <a-mixin id="vidFrame" geometry="primitive: plane; width: 0.4; height: 0.14"
                 material="shader: flat; color: #dfe4ea; " position=" 0 0 0.000001"></a-mixin>
        <a-mixin id="poiVidEscFrame" geometry="primitive: circle; radius: 0.05"
                 material="shader: flat; color: #dfe4ea; depthTest: false; transparent: true" position="0.15 0.15 0.000001"></a-mixin>

        <!-- <a-mixin id="vidTitleFrame" geometry="primitive: plane; width: 0.4; height: 0.05"
                 material="shader: flat; color: #dfe4ea; " position=" 0 0.11 0.000001"></a-mixin> -->
        <!--
                         <a-mixin id="vidFrame" geometry="primitive: plane; width: 0.2; height: 0.3"
                         material="shader: flat; color: #dfe4ea; " position=" 0 0 0.000001"></a-mixin>
                <a-mixin id="vidTitleFrame" geometry="primitive: plane; width: 0.4; height: 0.05"
                         material="shader: flat; color: #dfe4ea; " position=" 0 0.2 0.000001"></a-mixin> -->
    </a-assets>

    <a-entity id="player"></a-entity>

</a-scene>


<script>

    // Event listener when VR is toggled
    document.querySelector('a-scene').addEventListener('enter-vr',  function () {
        browsingModeVR = true;
    });

    document.querySelector('a-scene').addEventListener('exit-vr',  function () {
        browsingModeVR = false;
    });

    // All asets have loaded
    document.querySelector('#scene-assets').addEventListener('loaded', function() {

        console.log('Assets Loaded');

        if(document.getElementById("chat-wrapper-el").getAttribute('data-visible') === 'true') {
            document.getElementById("chat-wrapper-el").style.visibility = 'visible';
        }

    });


    /* CHAT COMPONENT */
    let sendMsgChatBtn = document.getElementById('send-msg-chat-btn');
    let chatInput = document.getElementById('chatInput');
    let chatLog = document.getElementById('chat-messages');

    NAF.connection.subscribeToDataChannel("chat", (senderId, dataType, data, targetId) => {
        let dateString = getChatCurrentTimeString();
        chatLog.innerHTML += '<span style=" color: ' + data.player.color + '">‚Ä¢</span> <span style="color: #80c9d4">' + dateString + ' ' + data.player.name + ": " + data.txt + '</span><br>';
    } )

    sendMsgChatBtn.addEventListener("click", evt => {
        let player_object = document.getElementById('cameraA').getAttribute('player-info', 'name');

        let dateString = getChatCurrentTimeString();
        chatLog.innerHTML += '<span>' + dateString + ' Me: ' + chatInput.value + '</span><br>';
        NAF.connection.broadcastData("chat", {txt: chatInput.value, player: player_object })

    })

    let chatExpanded = false;
    let chatMinimized = false;
    document.getElementById('expand-chat-btn').addEventListener("click", function() {
        let chatWrapper = document.getElementById("chat-wrapper-el");
        let messagesWrapper = document.getElementById("chat-messages-wrapper");

        if (chatMinimized) {
            chatExpanded = false;
        }
        else {
            if (chatExpanded) {
                chatWrapper.classList.add("ChatWrapperStyle");
                chatWrapper.classList.remove("ChatWrapperStyleExpanded");
                messagesWrapper.classList.add("ChatMessagesStyleNormal");
                messagesWrapper.classList.remove("ChatMessagesStyleExpanded");
                chatExpanded = false;
            } else {
                chatWrapper.classList.add("ChatWrapperStyleExpanded");
                chatWrapper.classList.remove("ChatWrapperStyle");
                messagesWrapper.classList.add("ChatMessagesStyleExpanded");
                messagesWrapper.classList.remove("ChatMessagesStyleNormal");
                chatExpanded = true;
            }
        }
    });

    document.getElementById('minimize-chat-btn').addEventListener("click", function() {
        let chatWrapper = document.getElementById("chat-wrapper-el");
        let messagesWrapper = document.getElementById("chat-messages-wrapper");

        chatWrapper.classList.add("ChatWrapperStyle");
        chatWrapper.classList.remove("ChatWrapperStyleExpanded");
        messagesWrapper.classList.remove("ChatMessagesStyleExpanded");

        if (chatMinimized) {
            messagesWrapper.classList.add("ChatMessagesStyleNormal");
            messagesWrapper.classList.remove("ChatMessagesStyleMinimized");
            chatMinimized = false;
        } else {
            messagesWrapper.classList.add("ChatMessagesStyleMinimized");
            messagesWrapper.classList.remove("ChatMessagesStyleNormal");
            chatExpanded = false;
            chatMinimized = true;
        }
    });

    const api_pattern_single = {
        ThresholdMin: 0.106,
        ThresholdMax: 0.13,
        red: 48, green: 146, blue: 89,
        w: 1, h: 0.75,
        x: 0, y: 0, z: 0,
        rx: 0, ry: 0, rz: 0
    };

    const api_pattern_singleMin = {
        ThresholdMinLow: 0,
        ThresholdMaxLow: 0,
        redLow: 0,
        greenLow: 0,
        blueLow: 0,
        wLow: 0.1,
        hLow: 0.1,
        xLow: -100000,
        yLow: -100000,
        zLow: -100000,
        rxLow: -100,
        ryLow: -100,
        rzLow: -100
    };
    const api_pattern_singleMax = {
        ThresholdMinHigh: 0.4,
        ThresholdMaxHigh: 0.4,
        redHigh: 255,
        greenHigh: 255,
        blueHigh: 255,
        wHigh: 5,
        hHigh: 5,
        xHigh: 100000,
        yHigh: 100000,
        zHigh: 100000,
        rxHigh: 100,
        ryHigh: 100,
        rzHigh: 100
    };
    const api_pattern_singleStep = {
        ThresholdMinStep: 0.001,
        ThresholdMaxStep: 0.001,
        redStep: 1,
        greenStep: 1,
        blueStep: 1,
        wStep: 0.05,
        hStep: 0.05,
        xStep: 10,
        yStep: 10,
        zStep: 10,
        rxStep: 0.1,
        ryStep: 0.1,
        rzStep: 0.1
    };

    let btStatusControls = document.getElementById('obtainStatusAndSetSizeControls');
    btStatusControls.addEventListener('click', function () {

        let entities = window.NAF.connection.entities.entities;
        let panelsSizeControlsDiv = document.getElementById('panelsSizeControlsDiv');

        /* Clear Panels Size  Controls */
        panelsSizeControlsDiv.replaceChildren([]);

        /* DestroyGui */
        try {
            console.log("destroying");
            if (btStatusControls.gui) {
                btStatusControls.gui.destroy();
            }
        }
        catch (e) {
            console.log(e);
        }

        btStatusControls.gui = new dat.GUI({ width: 200 });

        let elementsDatGui = [];
        let videoUserGui = [];

        let nActor = 0;

        if (entities) {

            /* Canvas Size Controls */
            let panel = {};
            for (let e in entities) {

                let h = window.NAF.connection.entities.entities[e].childNodes[1].getAttribute('height');
                if (h) {
                    nActor++;

                    /*  Thresholds Green */
                    videoUserGui[e] = btStatusControls.gui.addFolder(e);

                    /*  Panels  */
                    panel[e] = window.NAF.connection.entities.entities[e].childNodes[0].id === "videoPlaneGreen" ?
                        window.NAF.connection.entities.entities[e].childNodes[0] :
                        window.NAF.connection.entities.entities[e].childNodes[1];

                    elementsDatGui[e] = [];
                    for (let a in api_pattern_single) {

                        let L = a + "Low";
                        let H = a + "High";
                        let S = a + "Step";

                        elementsDatGui[e][a] = videoUserGui[e].add(api_pattern_single, a, api_pattern_singleMin[L], api_pattern_singleMax[H], api_pattern_singleStep[S]);

                        if (a[0] === 'w'
                            || a[0] === 'h'
                            || a[0] === 'x'
                            || a[0] === 'y'
                            || a[0] === 'z'
                            || a.substring(0, 2) === 'rx'
                            || a.substring(0, 2) === 'ry'
                            || a.substring(0, 2) === 'rz') {

                            elementsDatGui[e][a].panelaki = panel[e];
                            elementsDatGui[e][a].domElement.pName = e;

                            switch (a[0]) {
                                case 'w':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[5].panelaki;
                                        p.setAttribute('width', api_pattern_single[this.property]);
                                    });
                                    break;
                                case 'h':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[6].panelaki;
                                        p.setAttribute('height', api_pattern_single[this.property]);
                                    });
                                    break;
                                case 'x':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[7].panelaki;
                                        p.getAttribute('position').x = api_pattern_single[this.property] / 10000;
                                    });
                                    break;
                                case 'y':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[8].panelaki;
                                        p.getAttribute('position').y = api_pattern_single[this.property] / 10000;
                                    });
                                    break;
                                case 'z':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[9].panelaki;
                                        p.getAttribute('position').z = api_pattern_single[this.property] / 10000;
                                    });
                                    break;


                            }

                            switch (a.substring(0, 2)) {

                                case 'rx':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[10].panelaki;
                                        let xStr = api_pattern_single[this.property];
                                        let yStr = p.getAttribute('rotation').y;
                                        let zStr = p.getAttribute('rotation').z;
                                        p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                    });
                                    break;

                                case 'ry':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[11].panelaki;
                                        let xStr = p.getAttribute('rotation').x;
                                        let yStr = api_pattern_single[this.property];
                                        let zStr = p.getAttribute('rotation').z;
                                        p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                    });
                                    break;

                                case 'rz':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[12].panelaki;
                                        let xStr = p.getAttribute('rotation').x;
                                        let yStr = p.getAttribute('rotation').y;
                                        let zStr = api_pattern_single[this.property];
                                        p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                    });
                                    break;
                            }

                        } else {
                            elementsDatGui[e][a].onChange(function () {
                                let domAffected = document.getElementsByClassName("videoPlaneGreenClass")[elementsDatGui[e][a].nActor];
                                domAffected.setAttribute("networked-video-source", this.property, api_pattern_single[this.property]);
                            });
                        }
                        elementsDatGui[e][a].nActor = nActor - 1;
                    }
                }
            }
        }
    });

    /* Called by Networked-Aframe when connected to server */
    function onConnect() {
        console.log("onConnect", new Date());

        const screenBtnEle = document.getElementById('screen-btn-sendscreen');
        screenBtnEle.addEventListener('click', function () {
            navigator.mediaDevices.getDisplayMedia({
                preferCurrentTab: true,
                selfBrowserSurface: 'include',
                audio: true
            }).then((stream) => {
                NAF.connection.adapter.addLocalMediaStream(stream, "screen");
            });
        });
    }

    let record_button = document.getElementById('start-recording-btn');
    let video_preview = document.getElementById('video-preview');

    let download_button = document.getElementById('download-recording-btn');
    download_button.style.visibility = 'hidden';
    let upload_button = document.getElementById('upload-recording-btn');
    let capture_label = document.getElementById('captured-video-label');
    let recording = document.getElementById('recording');

    function startRecording(stream) {

        let recorder = new MediaRecorder(stream);
        let data = [];

        recorder.ondataavailable = event => data.push(event.data);
        recorder.start();

        let stopped = new Promise((resolve, reject) => {
            recorder.onstop = resolve;
            recorder.onerror = event => reject(event.name);
        });

        return Promise.all([
            stopped
        ]).then(() => data);
    }

    function stopRecording(stream) {
        stream.getTracks().forEach(track => track.stop());
        record_button.disabled = false;
        download_button.style.visibility = 'visible';
        upload_button.disabled = false;
    }

    let recordedBlob;

    record_button.addEventListener("click", function () {

        capture_label.innerHTML = '';

        navigator.mediaDevices.getDisplayMedia({
            preferCurrentTab: true,
            selfBrowserSurface: 'include',
            systemAudio: 'include',
            video: {
                cursor: 'never'
            },
            audio: true
        }).then(stream => {

            record_button.disabled = true;
            download_button.style.visibility = 'hidden';

            video_preview.style.display = 'block';
            video_preview.srcObject = stream;
            download_button.href = stream;
            video_preview.captureStream = video_preview.captureStream || video_preview.mozCaptureStream;

            stream.getVideoTracks()[0].onended = function () {
                video_preview.style.display = 'none';
                stopRecording(video_preview.srcObject);
            };

            return new Promise(resolve => video_preview.onplaying = resolve);
        }).then(() => startRecording(video_preview.captureStream()))
            .then(recordedChunks => {

                recordedBlob = new Blob(recordedChunks, { type: "video/webm" });
                recording.src = URL.createObjectURL(recordedBlob);
                download_button.style.visibility = 'visible';
                download_button.href = recording.src;
                download_button.download = "RecordedVideo.webm";

                upload_button.href = recording.src;
                capture_label.innerHTML = "Recorded " + formatBytes(recordedBlob.size) + " of " +
                    recordedBlob.type + " media.";

            });
    }, false);

    upload_button.addEventListener("click", function () {

        upload_button.disabled = true;

        const mv_url = document.getElementById('node-url-input').value;
        const mv_token = document.getElementById('node-token-input').value;
        const mv_project_id = document.getElementById('mv-project-id-input').value;

        const video_file = new File([recordedBlob], 'vrodos-' + recordedBlob.size + '.webm', {
            type: recordedBlob.type,
        });

        let formData = new FormData();
        formData.append('file', video_file);

        fetch(mv_url + '/dam/assets?description=' + 'Recorded video from VROdos' + '&externalTool=VRodos', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${mv_token}`
            },
            body: formData
        }).then(function (response) {
            if (response.ok) {
                return response.json();
            } else {
                upload_button.disabled = false;
                alert("There has been a problem uploading your video to MediaVerse platform");
            }
        }).then(function (data) {

            fetch(mv_url + '/dam/project/' + mv_project_id + '/projectOutput', {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${mv_token}`
                },
                body: JSON.stringify({
                    "projectOutput": [data.key]
                })
            }).then(function (response) {
                upload_button.disabled = false;
                if (response.ok) {
                    alert('The video has been successfully uploaded to MediaVerse!');
                } else {
                    alert("There has been a problem uploading your video to MediaVerse platform");
                    console.log(response.json());
                }
            })
        });
    });

    /* x button show clacket. key code 88 */
    document.addEventListener('keydown', function (e) {
        if (e.keyCode === 88) {
            document.getElementById('actionsDiv').style.display = 'block';

            if (document.getElementsByClassName('dg ac')[0]) {
                document.getElementsByClassName('dg ac')[0].style.display = 'block';
            }

            if (document.cancelFullScreen) {
                document.cancelFullScreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.webkitCancelFullScreen) {
                document.webkitCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }
    });

    /* Make full screen and hide controls */
    let director_controls = document.getElementById("toggle_controls");
    director_controls.onclick = function () {

        document.getElementById('actionsDiv').style.display = 'none';

        if (document.getElementsByClassName('dg ac')[0]) {
            document.getElementsByClassName('dg ac')[0].style.display = 'none';
        }

        let elem = document.body;

        if (elem.requestFullScreen) {
            elem.requestFullScreen();
        } else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
        } else if (elem.webkitRequestFullScreen) {
            elem.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
        } else if (elem.msRequestFullscreen) {
            elem.msRequestFullscreen();
        }
    };

    let formatBytes = (bytes, decimals = 2) => {
        if (!+bytes) return '0 Bytes'

        const k = 1024
        const dm = decimals < 0 ? 0 : decimals
        const sizes = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']

        const i = Math.floor(Math.log(bytes) / Math.log(k))

        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`
    };

    let getChatCurrentTimeString = () => {
        let date = new Date;
        return '[' + String(date.getHours()).padStart(2, '0') + ':' +
            String(date.getMinutes()).padStart(2, '0') + ':' +
            String(date.getSeconds()).padStart(2, '0') + ']';
    }

</script>

<!-- This will change the glb materials -->
<!-- <script src="js/glb_material_changer.js"></script> -->

</body>

</html>
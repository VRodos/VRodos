<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Collaborative content creation</title>
    <meta name="description" content="Collaborative content creation" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <script src="js/aframe/1.4.2/aframe-v1.4.2.min.js"></script>
    <!--<script src="js/aframe/1.5.0/aframe-v1.5.0.min.js"></script>-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.5.0/socket.io.slim.js"></script>
    <script src="js/datgui/0.7.9/dat.gui.min.js"></script>

    <script src="../easyrtc/easyrtc.js"></script>
    <script src="../dist/networked-aframe.js"></script>

    <!--<script src="js/a-water_alphamask_master.js"></script>-->
    <script src="js/sunsky/3.0.4/aframe-sun-sky.min.js"></script>

    <script src="js/highlight_img.js"></script>

    <script src="js/components/poi-image_component.js"></script>
    <script src="js/components/poi-help_component.js"></script>
    <script src="js/components/indicator_component.js"></script>
    <script src="js/components/poi-link_component.js"></script>
    <script src="js/components/door_component.js"></script>
    <script src="js/components/video_component.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/aframe-extras@7.2.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-environment-component@1.3.4/dist/aframe-environment-component.min.js"></script>


    <!-- Import Model Viewer component (to integrate ReadyPlayerMe api) -->
    <script type="module" src="https://cdn.jsdelivr.net/npm/@google/model-viewer@3.4.0/dist/model-viewer-module.min.js"></script>

    <script src="js/indicators_aframe.js"></script>
    <script src="dist/material-components-web.min.js"></script>

    <link rel="stylesheet" type="text/css" href="css/adv-screen.css" />
    <link rel="stylesheet" type="text/css" href="dist/material-components-web.min.css" />
    <link rel="stylesheet" type="text/css" href="css/material-icons/material-icons.css" />



    <!---- Blink Controls ---->

    <!-- <script src="https://cdn.jsdelivr.net/npm/aframe-blink-controls/dist/aframe-blink-controls.min.js"></script> -->

    <script src="https://cdn.jsdelivr.net/npm/aframe-blink-controls/dist/aframe-blink-controls.min.js"></script>

    <script>



        const vectorRequiresUpdateRotation = epsilon => {
            return () => {
                let prev = null;

                return curr => {
                    if (prev === null) {
                        prev = new THREE.Vector3(curr.x, curr.y, curr.z);
                        return true;
                    } else if (!NAF.utils.almostEqualVec3(prev, curr, epsilon)) {
                        curr.x = 0;

                        prev.copy(curr);
                        return true;
                    }

                    return false;
                };
            };
        };
        // Global variable to switch between interfaces for interaction modes.
        let browsingModeVR = false;

        /* PLAYER AVATARS (COLOR AND NAME) */
        // Temporary workaround for template declaration; see issue 167
        NAF.schemas.getComponentsOriginal = NAF.schemas.getComponents;
        NAF.schemas.getComponents = (template) => {
            if (!NAF.schemas.hasTemplate('#avatar-template-expo')) {
                NAF.schemas.add({
                    template: '#avatar-template-expo',
                    components: [
                        'position',
                        'player-info',
                        'avatar-movement-info',
                        {
                            selector: '.rpm_avatar', // the model entity has a .model class
                            component: 'gltf-model', // we want the gltf-model component to sync between clients
                        },
                        {
                            component: 'rotation',
                            requiresNetworkUpdate: vectorRequiresUpdateRotation(0.5)
                        }

                    ]
                });
            }
            return NAF.schemas.getComponentsOriginal(template);
        };

        AFRAME.registerComponent('clear-frustum-culling', {
            init: function () {
                let el = this.el;
                el.addEventListener("model-loaded", e => {
                    let mesh = el.getObject3D('mesh');
                    if (!mesh) { return; }
                    mesh.traverse(function (node) {
                        if (node.isMesh) {
                            node.frustumCulled = false;
                        }
                    });
                });
            }
        });

        AFRAME.registerComponent('scene-settings', {
            schema: {
                color:{type: "string", default: "#ffffff"},
                pr_type:{type: "string", default: "default"},
                img_link:{type: "string", default: "no_link"},
                selChoice:{type: "string", default: "0"},
                presChoice:{type: "string", default: "default"},
                movement_disabled:{type: "string", default: "0"},
                cam_position:{type: "string", default: "0 1.6 0"},
                cam_rotation_y:{type: "string", default: "0"},
                avatar_enabled:{type: "string", default: "0"},
                public_chat:{type: "string", default: "0"},
            },
            init: function () {

                let connectionResolve;
                let connectionPromise = new Promise((resolve, reject) => {
                    connectionResolve = resolve;


                })

                connectionPromise.then(() => {
                    // now you can access NAF.connection.getConnectedClients() safely here
                    // do stuff

                    console.log("PROMISE");
                    console.log(NAF.connection.getConnectedClients());
                })
                if (this.data.movement_disabled == "1")
                    if(this.data.pr_type == "vrexpo_games")
                        document.getElementById('cameraA').removeAttribute('wasd-controls');
                    else
                        document.getElementById('player').removeAttribute('wasd-controls');
                // console.log(wasd_controls);


                // Event - When scene is loaded
                this.el.addEventListener("loaded", () => {
                    if(this.data.pr_type == "vrexpo_games"){
                        console.log(this.data.cam_rotation_y);
                        document.getElementById("cameraA").setAttribute("position", this.data.cam_position);
                        //document.getElementById("player").setAttribute("rotation", "0 90 0");

                        //document.getElementById("cameraA").setAttribute("rotation", this.data.cam_rotation);
                    }

                    document.getElementById("private-chat-button").addEventListener("click", () => {
                        let event = new CustomEvent('chat-selected', {"detail": "private"});
                        document.dispatchEvent(event);
                    });

                    document.getElementById("public-chat-button").addEventListener("click", (evt) =>{
                        let event = new CustomEvent('chat-selected', {"detail": "public"});
                        document.dispatchEvent(event);
                    });

                    if(document.getElementById("aframe-scene-container").getAttribute("scene-settings").public_chat == "0"){

                        document.getElementById("private-chat-button").disabled = true;
                    }
                    else{
                        document.getElementById("public-chat-button").style.visibility = 'visible';
                        document.getElementById("public-chat-button").classList.add('mdc-tab--active');
                        document.getElementById("public-chat-button").disabled = true;
                    }



                    AFRAME.registerComponent('avatar-movement-info', {
                        // notice that color and name are both listed in the schema; NAF will only keep
                        // properties declared in the schema in sync.
                        schema: {
                            movementState: {
                                type: 'string',
                                default: ''
                            }

                        },

                        init: function () {
                            this.rpm_model = this.el.querySelector('.rpm_avatar');
                        },

                        update: function () {

                            if (this.el.querySelector('.rpm_avatar') && this.el.is('anims_loaded')) {
                                //elem.setAttribute("animation-player", evt.detail);
                                if(this.data.movementState != "stop"){
                                    this.el.querySelector('.rpm_avatar').setAttribute("animation-mixer", "clip:" + this.data.movementState + "; crossFadeDuration:0.3;");
                                }else{
                                    this.el.querySelector('.rpm_avatar').setAttribute("animation-mixer", "clip: idle; crossFadeDuration:1;");
                                }

                            }
                        }
                    });

                    AFRAME.registerComponent('avatar-rotation-info', {
                        // notice that color and name are both listed in the schema; NAF will only keep
                        // properties declared in the schema in sync.
                        schema: {
                            rotationState: {
                                type: 'string',
                                default: ''
                            }

                        },

                        init: function () {
                            this.rpm_model = this.el.querySelector('.rpm_avatar');
                        },

                        update: function () {

                            if (this.el.querySelector('.rpm_avatar') && this.el.is('anims_loaded')) {
                                //elem.setAttribute("animation-player", evt.detail);
                                if(this.data.movementState != "stop"){
                                    this.el.querySelector('.rpm_avatar').setAttribute("animation-mixer", "clip:" + this.data.movementState + "; crossFadeDuration:0.3;");
                                }else{
                                    this.el.querySelector('.rpm_avatar').setAttribute("animation-mixer", "clip: idle; crossFadeDuration:1;");
                                }

                            }
                        }
                    });


                    AFRAME.registerComponent('player-info', {
                        // notice that color and name are both listed in the schema; NAF will only keep
                        // properties declared in the schema in sync.
                        schema: {
                            name: {
                                type: 'string',
                                default: 'user-' + Math.round(Math.random() * 10000)
                            },
                            color: {
                                type: 'color', // btw: color is just a string under the hood in A-Frame
                                default: window.ntExample.randomColor()
                            },
                            gltf: {
                                default: '',
                                type: 'string'
                            },
                            avatarType: {
                                default: '',
                                type: 'string'
                            },
                            animationsLoaded: {
                                default: '',
                                type: 'string'
                            },
                            currentPrivateChat: {
                                default: '',
                                type: 'string'
                            },
                            fullChatTable: {
                                default: [],
                                type: 'array'
                            },
                            connectedUsers: {
                                default: 0,
                                type: 'number'
                            }

                        },

                        init: function () {
                            this.head = this.el.querySelector('.head');
                            this.face = this.el.querySelector('.face');
                            this.nametag = this.el.querySelector('.nametag');
                            this.rpm_model = this.el.querySelector('.rpm_avatar');
                            this.anims_loaded = false;

                            var elem = this.el;
                            if (elem.querySelector('.rpm_avatar')) {
                                elem.querySelector('.rpm_avatar').addEventListener('stateadded', function (evt) {
                                    if (evt.detail == 'loadedanimations'){
                                        console.log("Animations loaded");
                                        this.anims_loaded = true;
                                        elem.addState('anims_loaded');

                                    }
                                });


                            }

                            this.avatar_type = this.el.querySelector('.avatar_type');

                            this.ownedByLocalUser = this.el.id === 'cameraA';
                            if (this.ownedByLocalUser) {
                                // populate the html overlay with the correct name on init
                                this.nametagInput = document.getElementById('username-overlay');
                                this.nametagInput.value = this.data.name;

                                // add the initial color to the html overlay color picker button
                                document.getElementById('color-changer').style.backgroundColor = this.data.color;
                                document.getElementById('color-changer').style.color = this.data.color;
                            }
                        },

                        // here as an example, not used in current demo. Could build a user list, expanding on this.
                        listUsers: function () {
                            console.log(
                                'userlist',
                                [...document.querySelectorAll('[player-info]')].map((el) => el.components['player-info'].data.name)
                            );
                        },

                        newRandomColor: function () {
                            this.el.setAttribute('player-info', 'color', window.ntExample.randomColor());
                        },

                        update: function () {

                            var elem = this.el;

                            if (this.data.avatarType) {

                                if (this.data.avatarType === 'no-avatar') {

                                    if (!this.ownedByLocalUser) {
                                        this.head.setAttribute("visible", "false");
                                        this.face.setAttribute("visible", "false");
                                    }

                                    const parent_avatar = document.getElementById('cameraA');
                                    let my_head = parent_avatar.querySelector('.head');
                                    let my_face = parent_avatar.querySelector('.face');
                                    if (my_face) my_face.setAttribute("visible", "false");
                                    if (my_head) my_head.setAttribute("visible", "false");

                                } else if (this.data.avatarType === 'blob') {

                                    if (this.head) {
                                        this.head.setAttribute('material', 'color', this.data.color);
                                        this.head.setAttribute('visible', 'true');
                                        this.face.setAttribute('visible', 'true');
                                    }
                                    if (this.nametag) {
                                        this.nametag.setAttribute('value', this.data.name);
                                        this.nametag.setAttribute('visible', 'true');
                                    }

                                } else if (this.data.avatarType === 'rpm') {

                                    if (this.rpm_model) {
                                        // Set GLTF path to entity
                                        this.rpm_model.removeAttribute('gltf-model');
                                        this.rpm_model.setAttribute('gltf-model', this.data.gltf);


                                        // Event listener when the 3D model has actually loaded
                                        this.rpm_model.addEventListener('model-loaded', () => {

                                            let avatarType = this.rpm_model.object3DMap.mesh.children[0].userData.name;
                                            // Change Y position of model based on type

                                            let avatarPosition = avatarType === 'Armature' ? "0 -1.68  0" : '0 -.4 0';
                                            this.rpm_model.setAttribute('position', avatarPosition);
                                        }, {once : true});
                                    }

                                    if (this.nametag) {
                                        this.nametag.setAttribute('value', this.data.name);
                                        this.nametag.setAttribute('position', '0.25 0.6 0');
                                        this.nametag.setAttribute('visible', 'true');
                                    }
                                }
                            }
                        }
                    });

                    // If base scene, launch avatar selector
                    /*if (document.getElementById("is-base-scene-input").value === 'true' ) {*/

                    console.log(document.getElementById("aframe-scene-container").getAttribute("scene-settings").avatar_enabled);


                    let avatar_dialog_element = new mdc.dialog.MDCDialog(document.querySelector('#avatar-selection-dialog'))

                    let closeAvatarDialogListener = function(event) {
                        avatar_dialog_element.unlisten("MDCDialog:cancel", closeAvatarDialogListener);
                        selectAvatarType('no-avatar');
                    };
                    if (document.getElementById("aframe-scene-container").getAttribute("scene-settings").avatar_enabled == 1 && document.getElementById("aframe-scene-container").getAttribute("scene-settings").pr_type == "vrexpo_games"){
                        avatar_dialog_element.show();
                        avatar_dialog_element.listen("MDCDialog:cancel", closeAvatarDialogListener);
                    }else{
                        selectAvatarType('no-avatar');
                    }

                    /*}*/

                });

                this.el.addEventListener("enter-vr", () => {
                    browsingModeVR = true;
                });
                this.el.addEventListener("exit-vr", () => {
                    browsingModeVR = false;
                });

                let cam = document.querySelector("#cameraA");

                if (this.data.pr_type !== "vrexpo_games")
                    cam.setAttribute("camera", "fov: 60");
                else{
                    cam.setAttribute("fov", "60");
                    cam.setAttribute("camera", "fov: 60"); //temp based on camera settings

                    // Hide eyes from my avatar on self
                    const parent_avatar = document.getElementById('cameraA');
                    let my_face = parent_avatar.querySelector('.face');
                    if (my_face) my_face.setAttribute("visible", "false");

                }

                let backgroundEl = document.querySelector('#aframe-scene-container');

                if (!this.data.selChoice)
                    this.data.selChoice = "0";

                switch(this.data.selChoice){
                    case "0":
                        backgroundEl.setAttribute("background", "color", "#ffffff");

                        break;
                    case "1":
                        backgroundEl.setAttribute("background", "color", this.data.color);
                        break;
                    case "2":
                        if (this.data.presChoice == "ocean")
                        {
                            let sky = document.createElement('a-sky');
                            sky.setAttribute("color", "#a4bede");
                            backgroundEl.appendChild(sky);

                            let plane = document.createElement('a-plane');
                            plane.setAttribute("color", "#ffffff");
                            plane.setAttribute("position", "0 4.5 0");
                            plane.setAttribute("height", "11");
                            plane.setAttribute("width", "11");
                            plane.setAttribute("rotation", "90 90 0");
                            plane.setAttribute("material", "opacity:0.4");
                            plane.setAttribute("scale", "15 15 15");
                            plane.setAttribute("class", "ocean_asset");
                            backgroundEl.appendChild(plane);

                            let entity = document.createElement('a-entity');
                            entity.setAttribute("color", "#b6e8fe");
                            entity.setAttribute("position", "0 4 0");
                            entity.setAttribute("class", "ocean_asset");

                            let ocean_top = document.createElement('a-ocean');
                            ocean_top.setAttribute("width", "50");
                            ocean_top.setAttribute("depth", "50");
                            ocean_top.setAttribute("density", "40");
                            ocean_top.setAttribute("class", "ocean_asset");



                            let animation = document.createElement('a-animation');
                            animation.setAttribute("attribute", "visible");
                            animation.setAttribute("delay", "25000");
                            animation.setAttribute("to", "true");

                            ocean_top.appendChild(animation);
                            entity.appendChild(ocean_top);
                            backgroundEl.appendChild(entity);


                            let ocean_shadow = document.createElement('a-ocean');
                            ocean_shadow.setAttribute("width", "50");
                            ocean_shadow.setAttribute("depth", "50");
                            ocean_shadow.setAttribute("density", "50");
                            ocean_shadow.setAttribute("color", "#75705e");
                            ocean_shadow.setAttribute("position", "0 -0.15 0");
                            ocean_shadow.setAttribute("opacity", "0.03");
                            ocean_shadow.setAttribute("class", "ocean_asset");

                            let animation_shadow = document.createElement('a-animation');
                            animation_shadow.setAttribute("attribute", "visible");
                            animation_shadow.setAttribute("delay", "55000");
                            animation_shadow.setAttribute("to", "true");

                            ocean_shadow.appendChild(animation_shadow);

                            backgroundEl.appendChild( ocean_shadow);

                            let plane_seafloor = document.createElement('a-plane');
                            plane_seafloor.setAttribute("id", "seafloorCoral");
                            plane_seafloor.setAttribute("color", "#d9d0ae");
                            plane_seafloor.setAttribute("position", "0 0 0");
                            plane_seafloor.setAttribute("height", "4");
                            plane_seafloor.setAttribute("width", "4");
                            plane_seafloor.setAttribute("rotation", "-90 0 0");
                            plane_seafloor.setAttribute("scale", "15 15 15");
                            plane_seafloor.setAttribute("class", "ocean_asset");

                            backgroundEl.appendChild(plane_seafloor);

                            let light_a = document.createElement('a-entity');
                            light_a.setAttribute("light", "type: hemisphere; color: #ffffff; groundColor: #000000; intensity: 0.9;");
                            light_a.setAttribute("position", "25 8 -25");

                            let light_b = document.createElement('a-entity');
                            light_b.setAttribute("light", "type: hemisphere; color: #ffffff; groundColor: #000000; intensity: 0.3;");
                            light_b.setAttribute("position", "25 8 25");

                            let light_c = document.createElement('a-entity');
                            light_c.setAttribute("light", "type: ambient; color: #ffffff; intensity: 0.5;");
                            light_c.setAttribute("position", "25 8 -25");

                            backgroundEl.appendChild(light_a);
                            backgroundEl.appendChild(light_b);
                            backgroundEl.appendChild(light_c);


                            let audio_track = document.createElement('audio');
                            audio_track.setAttribute("preload", "auto");
                            audio_track.setAttribute("id", "underwater-sound");
                            audio_track.setAttribute("src", "../media/sound/underwater.mp3");

                            backgroundEl.appendChild(audio_track);

                            let sound = document.createElement('a-entity');
                            sound.setAttribute("sound", "src: #underwater-sound; loop: true; volume: 1; positional:false");
                            sound.setAttribute("position", "0 4 0");
                            sound.setAttribute("autoplay-sound", "");

                            backgroundEl.appendChild(sound);


                            backgroundEl.setAttribute("fog","type: exponential; color: #0894d3; density: 0.06;");


                        }else{
                            backgroundEl.setAttribute("environment", "preset", this.data.presChoice);
                            //backgroundEl.setAttribute("environment", "ground", "flat");
                            backgroundEl.setAttribute("environment", "playArea", "1.4");
                            backgroundEl.setAttribute("environment", "shadow", "true");

                            let groundEl = document.getElementsByClassName('environmentGround')[0];
                            groundEl.setAttribute("shadow", "cast: true; receive: true");
                        }


                        break;
                    case "3":

                        let customImgAsset = document.querySelector('#custom_sky');
                        if(customImgAsset.getAttribute("src")){
                            let skyElem = document.createElement('a-sky');
                            skyElem.setAttribute("id", "sky");
                            skyElem.setAttribute("src",  "#custom_sky");
                            backgroundEl.appendChild(skyElem);
                        }
                        else{
                            backgroundEl.setAttribute("background", "color", "#ffffff");
                        }


                        break;
                }
            }
        });
        AFRAME.registerComponent('autoplay-sound', {
            init:function() {
                this.el.addEventListener("loaded", () => {
                    this.el.components.sound.playSound();
                });
            }
        });

        AFRAME.registerComponent('entity-movement-emitter', {
            schema: {
                clip:{type: "string", default: "idle"},
            },
            init:function() {

                var bind = AFRAME.utils.bind;
                var shouldCaptureKeyEvent = AFRAME.utils.shouldCaptureKeyEvent;
                var elem = this.el;

                document.addEventListener('keydown', function(event) {
                    if(event.keyCode === 87) {
                        if (shouldCaptureKeyEvent(event)) {
                            document.getElementById('cameraA').setAttribute('avatar-movement-info', 'movementState', "walkingforward");
                        }
                    }else if(event.keyCode === 83){
                        if (shouldCaptureKeyEvent(event)) {
                            elem.emit('avatar-changed-animation', "walkingdown", false);
                            document.getElementById('cameraA').setAttribute('avatar-movement-info', 'movementState', "walkingdown");
                        }

                    }else if(event.keyCode === 68){
                        if (shouldCaptureKeyEvent(event)) {
                            elem.emit('avatar-changed-animation', "walkingright", false);
                            document.getElementById('cameraA').setAttribute('avatar-movement-info', 'movementState', "walkingright");
                        }

                    }else if(event.keyCode === 65){
                        if (shouldCaptureKeyEvent(event)) {
                            elem.emit('avatar-changed-animation', "walkingleft", false);
                            document.getElementById('cameraA').setAttribute('avatar-movement-info', 'movementState', "walkingleft");
                        }
                    }
                    else{
                        elem.emit('avatar-changed-animation', "idle", false);
                    }

                });
                document.addEventListener('keyup', function(event) {
                    elem.emit('avatar-changed-animation', "stopped", false);
                    document.getElementById('cameraA').setAttribute('avatar-movement-info', 'movementState', "stop");
                });


            }
        });

        AFRAME.registerComponent('entity-rotation-emitter', {
            init:function() {

                var bind = AFRAME.utils.bind;
                this.el.addEventListener('componentchanged', function (evt) {
                    if (evt.detail.name === 'rotation') {
                        console.log('Entity has rotated');
                    }
                    //console.log(evt.detail);
                });
            }
        });



        AFRAME.registerComponent('animation-embed', {
            schema: {
                clip:{type: "string", default: "idle"},
            },
            init:function() {
                const animations = ["idle","walking"];
                var loader = new THREE.GLTFLoader();
                var id = this.data.glb_id;

                this.el.addEventListener("model-loaded", e => {
                    var objectMesh = this.el.getObject3D("mesh");

                    var bind = AFRAME.utils.bind;
                    var shouldCaptureKeyEvent = AFRAME.utils.shouldCaptureKeyEvent;
                    var link = "../assets/templates/multimalev2.glb";
                    var elem = this.el;
                    this.loaded_anims = false;
                    if (this.el.object3DMap.mesh.children[0].userData.name === "Armature"){
                        loader.load(link, function (gltf) {
                            for (let i = 0; i < gltf.animations.length; i++) {
                                objectMesh.animations[i] = gltf.animations[i];
                            }
                            elem.removeAttribute('animation-mixer');
                            elem.setAttribute('animation-mixer', "clip: idle");
                            elem.addState('loadedanimations');
                        });
                    }else {
                        elem.addState('noanimations');

                        elem.object3D.traverse((child) => {
                            if (child.name.includes('Hand')){
                                child.visible = false;
                            }
                        });
                    }
                });
            }
        });

        AFRAME.registerComponent('static-mask-me', {
            init: function () {
                let el = this.el;
                // el.addEventListener("model-loaded", e => {
                const maskMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: false,
                    colorWrite: false,
                });
                maskMaterial.needsUpdate = true;
                let mesh = el.getObject3D('mesh');
                if (!mesh) {
                    return;
                }
                mesh.traverse(node => {
                    if (!node.isMesh) {
                        return;
                    }
                    node.material = maskMaterial;
                    node.renderOrder = 999;
                });
                //  });
            },
            tick: null
        });

        AFRAME.registerComponent('render-order-change', {
            schema: {
                renderingOrderArg: { type: 'string', default: '2000' }
            },
            init: function () {
                let el = this.el;
                // el.addEventListener("model-loaded", e => {
                let mesh = el.getObject3D('mesh');
                if (!mesh) {
                    return;
                }
                mesh.traverse(node => {
                    if (!node.isMesh) {
                        return;
                    }
                    node.renderOrder = this.data.renderingOrderArg;

                });
                //  });
            },
            tick: null
        });


        AFRAME.registerComponent("overlay", {
            dependencies: ['material'],
            init: function () {
                this.el.sceneEl.renderer.sortObjects = true;
                this.el.object3D.renderOrder = 100;
                this.el.components.material.material.depthTest = false;
            }
        })




        AFRAME.registerComponent('show-position', {
            init: function () {
                this.positionShow = document.getElementById("positionShow");
                this.occupantsNumberShow = document.getElementById("occupantsNumberShow");
            },
            tick: function (time, timeDelta) {
                let p = this.el.getAttribute('position');
                this.positionShow.innerHTML = Math.round(p.x * 100) / 100 + ", " + Math.round(p.y * 100) / 100 + ", " + Math.round(p.z * 100) / 100;

                let occupants = window.easyrtc.getRoomOccupantsAsMap(window.NAF.room);
                if (occupants) {
                    this.occupantsNumberShow.innerHTML = Object.keys(occupants).length;
                }
            }
        });

        AFRAME.registerComponent('custom-movement', {
            init: function () {
                const cameraEl = document.querySelector('a-camera');
                const cameraRig = this.el;

                //console.log (cameraEl);

                const thumbL = document.querySelector('#leftHand');
                const thumbR = document.querySelector('#rightHand');

                thumbL.addEventListener('thumbstickmoved', (event) => {
                    // const thumbstickX = event.detail.x;
                    // const thumbstickY = event.detail.y;

                    // // Get camera rotation
                    // const rotation = cameraEl.getAttribute('rotation');
                    // const angleY = (rotation.y * Math.PI) / 180;


                    // // Calculate movement direction based on camera rotation
                    // const direction = new THREE.Vector3(-Math.sin(angleY), 0, -Math.cos(angleY));

                    // // Apply movement to the camera rig's position
                    // const movementSpeed = 0.1;
                    // cameraRig.object3D.translateX(-direction.x * thumbstickY * movementSpeed - direction.z * thumbstickX * movementSpeed);
                    // cameraRig.object3D.translateZ(-direction.z * thumbstickY * movementSpeed + direction.x * thumbstickX * movementSpeed);


                    // //console.log('Camera rotation:', rotation.x, rotation.y, rotation.z);
                });

                thumbR.addEventListener('thumbstickmoved', (event) => {

                    const thumbstickX = event.detail.x;
                    const thumbstickY = event.detail.y;

                    // Get camera rotation
                    const rotation = cameraEl.getAttribute('rotation');
                    const angleY = (rotation.y * Math.PI) / 180;


                    // Calculate movement direction based on camera rotation
                    const direction = new THREE.Vector3(-Math.sin(angleY), 0, -Math.cos(angleY));

                    // Apply movement to the camera rig's position
                    const movementSpeed = 0.1;
                    cameraRig.object3D.translateX(-direction.x * thumbstickY * movementSpeed - direction.z * thumbstickX * movementSpeed);
                    cameraRig.object3D.translateZ(-direction.z * thumbstickY * movementSpeed + direction.x * thumbstickX * movementSpeed);


                    //console.log('Camera rotation:', rotation.x, rotation.y, rotation.z);
                });

                thumbR.addEventListener('thumbstickmoved', (event) => {

                    // //console.log('Right thumbstick activated');
                    // if (event.detail.y === 1) {  // Assuming y value of thumbstick indicates a button press
                    //     const blinkControlsScript = document.createElement('script');
                    //     blinkControlsScript.src = 'https://cdn.jsdelivr.net/npm/aframe-blink-controls/dist/aframe-blink-controls.min.js';
                    //     document.head.appendChild(blinkControlsScript);

                    //     blinkControlsScript.onload = () => {
                    //     console.log('aframe-blink-controls script loaded');
                    //     };
                    // }


                });

            }
        });

        AFRAME.registerComponent('start-animation', {
            init: function () {

                const avatar = document.getElementById('animated_avatar');
                /*const animationModel = document.querySelector('#animation-model');*/

                // Trigger the animation when the scene starts
                //animationModel.emit('start-scene');

                // Show the avatar and animation models
                //avatar.setAttribute('visible', 'true');

                //console.log("test");
                //animationModel.setAttribute('visible', 'true');
            }
        });

    </script>

    <style>
        .button-tab {
            background-color: #fff;
            border: 0 solid #e2e8f0;
            border-radius: 1.5rem;
            box-sizing: border-box;
            color: #0d172a;
            cursor: pointer;
            display: inline-block;
            font-family: "Basier circle",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1.1rem;
            font-weight: 600;
            padding: 1rem 1.6rem;
            text-align: center;
            text-decoration: none #0d172a solid;
            text-decoration-thickness: auto;
            transition: all .1s cubic-bezier(.4, 0, .2, 1);
            box-shadow: 0px 1px 2px rgba(166, 175, 195, 0.25);
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        @media (min-width: 768px) {
            .button-tab {
                font-size: 1.125rem;
                padding: 1rem 2rem;
            }
        }
        .ChatWrapperStyle {
            position: absolute;
            bottom: 0;
            height: auto;
        }
        .ChatWrapperStyleExpanded {
            position: absolute;
            height: auto;
        }
        .ChatMessagesStyle {
            width: 450px;
            background-color: rgba(0,0,0,.7);
            overflow:auto;
            z-index:100;
            bottom: 0;
            left:0;
            display: flex;
            flex-direction: column-reverse;
            font-family: Arial, Helvetica, sans-serif;
            font-size: 14px;
            color: #ccc;
            text-shadow: 1px 1px 2px black;
        }
        .ChatMessagesStyleNormal {
            height: 200px;
            position: relative;
        }
        .ChatMessagesStyleExpanded {
            height: 100%;
            position: fixed;
        }
        .ChatMessagesStyleMinimized {
            height: 0;
            position: relative;
        }

        .IconButtonStyle {
            background-color: transparent;
            cursor: pointer;
            border: none;
            height: 24px;
            width: 24px;
            margin: 0 auto;
            padding: 0 2px 0 2px;
        }
        .IconButtonStyle i {
            text-shadow: 0 0 3px #fff;
        }

        .AvatarTypeSelection img {
            display: block;
        }

        .AvatarTypeSelection label {
            /*width: 20vw;
            height: 20vw;*/
            padding: 1vw;
        }

        .AvatarTypeSelection input[type=radio] {
            display: none;
        }

        .AvatarTypeSelection label:hover {
            opacity:0.6;
            cursor: pointer;
        }

        .AvatarTypeSelection label:active {
            opacity:0.4;
            cursor: pointer;
        }

        .AvatarTypeSelection input[type=radio]:checked + label {
            border: 10px solid rgb(228, 207, 94);
        }

        .RpmIframeStyle {
            width: 1080px;
            height: 800px;
            margin: 0 auto;
            font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans,
            Droid Sans, Helvetica Neue, sans-serif;
            padding: 20px;
            font-size: 14px;
            border: none;
            position: relative;
            z-index: 9999;
        }




    </style>

</head>

<body id="master-client-body">
<div class="ChatWrapperStyle" id="chat-wrapper-el" style="visibility: hidden">

    <div class="mdc-tab-bar" role="tablist" style="position: relative; top: 0; right:30px; z-index:101; height: 30px;">
        <div class="mdc-tab-scroller">
            <div class="mdc-tab-scroller__scroll-area">
                <div class="mdc-tab-scroller__scroll-content">
                    <button id = "public-chat-button" class="mdc-tab button-tab" role="tab" aria-selected="true" tabindex="0" style="visibility: hidden">
                        <span class="mdc-tab__content">
                            <span class="mdc-tab__text-label">Public</span>
                        </span>

                        <span class="mdc-tab__ripple"></span>
                    </button>

                    <button id = "private-chat-button" class="mdc-tab button-tab" role="tab" aria-selected="true" tabindex="1"  style="visibility: hidden">
                        <span class="mdc-tab__content">
                        <span class="mdc-tab__text-label">Private</span>
                        </span>
                        <span class="mdc-tab-indicator mdc-tab-indicator">

                    </button>

                </div>
            </div>
        </div>
    </div>


    <div id="chatControlsOverlay" style="position: relative; top: 0; left:0; z-index:101; height: 30px;">
        <button id="color-changer" onclick="
            let newColor = window.ntExample.randomColor();
             document.getElementById('cameraA').setAttribute('player-info', 'color', newColor);
             document.getElementById('color-changer').style.backgroundColor = newColor;
             document.getElementById('color-changer').style.color = newColor;
        ">■</button>
        <input id="username-overlay" maxlength="24" size="15" oninput="document.getElementById('cameraA').setAttribute('player-info', 'name', this.value)" placeholder="Username" />
        <input type="text" id="chatInput" placeholder="Message">
        <button id="send-msg-chat-btn" style="right: 0; cursor: pointer">SEND</button>
        <button id="expand-chat-btn" class="IconButtonStyle" title="Chat Size"><i class="material-icons">unfold_more</i></button>
        <button id="minimize-chat-btn" class="IconButtonStyle" title="Minimize"><i class="material-icons">expand_more</i></button>
        <button id="exit-help-btn" class="IconButtonStyle" title="Exit Private Chat" style="display: none"><i class="material-icons">close</i></button>
    </div>
    <div class="ChatMessagesStyle ChatMessagesStyleNormal" id="chat-messages-wrapper">
        <div id="chat-messages"></div>
    </div>
</div>

<div id="mediaPanel">
    <div class="wrapperVideoElement" style="visibility: hidden">
        <video id="video-preview" width="300" height="200" autoplay muted></video>
        <video id="recording" hidden></video>
    </div>

    <div class="actionsDirector" name="actionsDiv" id="actionsDiv">
        <div id="toggle_controls">Close <span style="color: white">("x" button to show again)</span></div>
        <div id="directorline" style=""></div>


        <div class="wrapperControlElement">
            <label for="roomNameShow" title="Name of Room">&#127917;</label>
            <span id="roomNameShow">roomname</span>
        </div>

        <div class="wrapperControlElement">
            <label for="occupantsNumberShow" title="Number of actors">&#128101;</label>
            <span id="occupantsNumberShow"></span>
        </div>

        <div class="wrapperControlElement">
            <button id="obtainStatusAndSetSizeControls" class="buttonMultiplaying"
                    title="Obtain status and control green screens">
                &#128260; &#9989;
            </button>
        </div>

        <div class="wrapperControlElement" >
            <button id="screen-btn-sendscreen" class="buttonMultiplaying" title="Send scene stream back to actors">
                &#127909; &#9654; &#128101;
            </button>
        </div>

        <div class="wrapperControlLineElement">
            <button id="start-recording-btn" class="buttonStartRecord" title="Start capturing video">
                ⚪️
            </button>

            <a id="download-recording-btn" class="buttonDownloadRecording" title="Download video" style="visibility: hidden">
                💾️️
            </a>

            <button id="upload-recording-btn" class="buttonUploadRecording" style="visibility: hidden;"
                    title="Upload Recording to MediaVerse" disabled>
                ⬆️️️
            </button>
        </div>
        <div class="wrapperControlElement">
            <span id="captured-video-label"></span>
        </div>
        <div class="wrapperControlElement">
            <label for="positionShow" title="Camera Position">&#127909;</label>
            <span id="positionShow"></span>
        </div>

        <div id="panelsSizeControlsDiv"></div>
        <input id="node-url-input" hidden disabled />
        <input id="node-token-input" hidden disabled />
        <input id="is-base-scene-input" hidden disabled />
    </div>
</div>


<!-- Avatar selection -->
<aside id="avatar-selection-dialog" class="mdc-dialog" role="alertdialog" style="z-index: 1000;"
       aria-labelledby="Avatar selection popup" aria-describedby="You can select an avatar"
       data-mdc-auto-init="MDCDialog">
    <div class="mdc-dialog__surface">
        <header class="mdc-dialog__header">
            <h2 class="mdc-dialog__header__title">Welcome to our virtual exposition</h2>
        </header>

        <section class="mdc-dialog__body">
            <div class="mdc-layout-grid">
                <div class="mdc-layout-grid__inner">
                    <div class="mdc-layout-grid__cell--span-12">
                        <div style="text-align: center">
                            <h3 class="mdc-typography--headline">Please select an avatar type:</h3>
                            <form name="avatarRadiosForm">
                                <div class="mdc-form-field AvatarTypeSelection">
                                    <input class="mdc-radio__native-control" type="radio" id="no-avatar-radio" name="avatar-radios" value="no-avatar" checked>
                                    <label for="no-avatar-radio">
                                        <img src="media/img/no-avatar.png" width="128" height="128" style="opacity:.6" />
                                        <span>No avatar</span>
                                    </label>

                                    <input class="mdc-radio__native-control" type="radio" id="blob-radio" value="blob" name="avatar-radios" >
                                    <label for="blob-radio">
                                        <img src="media/img/blob-avatar.png" width="128" height="128" />
                                        <span>A Blob</span>
                                        <br>
                                        <span>(Default)</span>
                                    </label>

                                    <input class="mdc-radio__native-control" type="radio" id="rpm-radio" value="rpm" name="avatar-radios" >
                                    <label for="rpm-radio">
                                        <img src="media/img/rpm-avatar.png" width="128" height="128" />
                                        <span>Your personalized</span>
                                        <br>
                                        <span>3D avatar</span>
                                    </label>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <footer class="mdc-dialog__footer">
            <a id="selectAvatarBtn" onclick="selectAvatarType()" class="mdc-button mdc-button--primary mdc-dialog__footer__button mdc-dialog__footer__button--accept mdc-button--raised">OK</a>
        </footer>
    </div>
    <div class="mdc-dialog__backdrop"></div>
</aside>


<!-- IMG POI Dialog component -->
<aside id="poi-img-dialog" class="mdc-dialog" role="alertdialog" style="z-index: 1000;"
       aria-labelledby="Image POI popup" aria-describedby="Show Image POI details"
       data-mdc-auto-init="MDCDialog">
    <div class="mdc-dialog__surface">
        <header class="mdc-dialog__header">
            <h2 id="poi-img-dialog-title" class="mdc-dialog__header__title"></h2>
        </header>

        <section class="mdc-dialog__body">
            <div class="mdc-layout-grid">
                <div class="mdc-layout-grid__inner">
                    <div class="mdc-layout-grid__cell--span-12">
                        <div style="text-align: center">
                            <img src="" alt="Image POI Image" id="poi-img-dialog-image" style="width: auto; max-width: 100%;max-height: 260px;"/>
                        </div>
                        <div style="text-align: left; overflow-y: auto;  max-height: 300px;">
                            <span  class="mdc-typography--body1" id="poi-img-dialog-description"></span>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <footer class="mdc-dialog__footer">
            <a class="mdc-button mdc-button--primary mdc-dialog__footer__button mdc-dialog__footer__button--accept mdc-button--raised" >OK</a>
        </footer>
    </div>
    <div class="mdc-dialog__backdrop"></div>
</aside>

<aside id="video-controls-dialog" class="mdc-dialog" role="alertdialog" style="z-index: 1000;"
       aria-labelledby="Video controls popup" aria-describedby="Show Video controls">
    <div class="mdc-dialog__surface">

        <video controls controlsList="nodownload" id="video-panel-video" height="100%" width="100%" >
            Your browser does not support video.
        </video>

        <footer class="mdc-dialog__footer">
            <a class="mdc-button mdc-button--primary mdc-dialog__footer__button mdc-dialog__footer__button--cancel mdc-button--raised">Close</a>
            <a class="mdc-button mdc-button--primary mdc-dialog__footer__button mdc-dialog__footer__button--accept mdc-button--raised" style="display: none;" tabIndex="0">OK</a>
        </footer>
    </div>
    <div class="mdc-dialog__backdrop"></div>
</aside>

<!--Ready Player Me iframe-->
<div style="text-align: center;">
    <iframe id="rpm-iframe" class="RpmIframeStyle" allow="camera *; microphone *; clipboard-write" hidden></iframe>
</div>

<a-scene
        oculus-go-controls-enabled
        start-animation
        id="aframe-scene-container"
        fog="type: linear; color: #AAB; far: 230; near: 0"
        renderer="antialias: true;
            sortObjects: true;
            toneMapping: ACESFilmic;
            precision: high;
            alpha: true;"
        shadow="type: pcfsoft;"
        vr-mode-ui="enabled: true"
        loading-screen="dotsColor: gray; backgroundColor: black;"
      >
    <!--environment="ground:none"-->

    <a-assets id="scene-assets">

        <!-- Avatar Template -->
        <template id="avatar-template-expo">
            <a-entity class="avatar hideable" player-info avatar-movement-info>


                <!-- ReadyPlayerMe Avatar-->
                <a-entity
                        gltf-model
                        animation-embed="glb_id:ready-player-me-avatar"
                        id="ready-player-me-avatar"
                        class="rpm_avatar"
                        position="0 0 -0.5"
                        rotation="0 180 0"
                        animation-mixer="clip: test; autoPlay: true"
                        visible="true"
                        shadow="cast:true; receive:true;"
                >
                </a-entity>

                <!-- Sphere Avatar-->
                <a-sphere class="head" scale="0.2 0.18 0.2" visible="false" shadow="cast:true; receive:true;"></a-sphere>
                <a-entity class="face" position="0 0.05 0" visible="false">
                    <a-sphere class="eye" color="white" position="0.06 0.05 -0.16" scale="0.04 0.04 0.04" >
                        <a-sphere class="pupil" color="black" position="0 0 -1" scale="0.2 0.2 0.2" ></a-sphere>
                    </a-sphere>
                    <a-sphere class="eye" color="white" position="-0.06 0.05 -0.16" scale="0.04 0.04 0.04">
                        <a-sphere class="pupil" color="black" position="0 0 -1" scale="0.2 0.2 0.2"></a-sphere>
                    </a-sphere>
                </a-entity>


                <!-- Text component for a nametag; the value will be updated by the player-info component -->
                <a-text
                        class="nametag"
                        value="?"
                        rotation="0 180 0"
                        position="0.25 -0.35 0"
                        side="double"
                        scale=".5 .5 .5"
                        visible="false"
                ></a-text>
            </a-entity>
        </template>

        <!-- Avatar template for MediaVerse projects-->
        <template id="avatar-template">
            <a-entity class="avatar hideable" networked-audio-source>

                <a-plane id="videoPlaneGreen" class="videoPlaneGreenClass" color="#FFF" width="2" height="1.5"
                         position="0 0.6 -0.15" material="side: double"
                         networked-video-source="useGreenScreen: true; greenThreshold: 0.04; streamName: video"
                         render-order-change="2000">
                </a-plane>

                <a-plane id="screenPlane" color="#FFF" width="0" height="0" position="0 0.6 -0.15"
                         material="side: double" networked-video-source="streamName:screen">
                </a-plane>
            </a-entity>
        </template>

        <a-mixin id="vid_panel" geometry="primitive: plane; width: 0.5783552; height: 0.8192"
                 material="color: black; shader: flat"></a-mixin>
        <a-mixin id="frame" geometry="primitive: plane; width: 0.5783552; height: 0.8192"
                 material="color: white; shader: flat"
                 animation__scale="property: scale; to: 1.2 1.2 1.2; dur: 200;  startEvents: tmp1"
                 animation__scale_reverse="property: scale; to: 1 1 1; dur: 200; startEvents: tmp2"></a-mixin>
        <a-mixin id="poster" geometry="primitive: plane; width: 0.544768; height: 0.786432"
                 material="color: white; shader: flat" material="shader: flat" position="0 0 0.005"></a-mixin>
        <a-mixin id="poiImage" geometry="primitive: plane; width: 1.4; height: 0.8"
                 material="shader: flat;  transparent: true" position="0 0.455 0.002"></a-mixin>
        <a-mixin id="poiImageFull" geometry="primitive: plane; width: 1.4; height: 1.4"
                 material="shader: flat; transparent: true" position="0 0 0.002"></a-mixin>
        <a-mixin id="poiEsc" geometry="primitive: plane; width: 1; height: 1"
                 position="1 0.73 0.002"  material="shader: flat; transparent: true"></a-mixin>
        <a-mixin id="poiImgNext" geometry="primitive: plane; width: 1; height: 1"
                 material="shader: flat; transparent: true" position="1 -0.5 0.002"></a-mixin>
        <a-mixin id="poiImgPrev" geometry="primitive: plane; width: 1; height: 1"
                 material="shader: flat; transparent: true" position="-1 -0.5 0.002"></a-mixin>
        <a-mixin id="poiEscFrame" geometry="primitive: circle; radius: 0.15"
                 material="shader: flat; color: #dfe4ea; depthTest: false; transparent: true" position="1 0.73 0.002"></a-mixin>
        <a-mixin id="poiImgPrevFrame" geometry="primitive: circle; radius: 0.15"
                 material="shader: flat; color: #dfe4ea; depthTest: false; transparent: true" position="-1 -0.5 0.002"></a-mixin>
        <a-mixin id="poiImgNextFrame" geometry="primitive: circle; radius: 0.15"
                 material="shader: flat; color: #dfe4ea; depthTest: false; transparent: true" position=" 1 -0.5 0.002"></a-mixin>
        <a-mixin id="vidFrame" geometry="primitive: plane; width: 0.4; height: 0.14"
                 material="shader: flat; color: #dfe4ea; " position=" 0 0 0.000001"></a-mixin>
        <a-mixin id="poiVidEscFrame" geometry="primitive: circle; radius: 0.05"
                 material="shader: flat; color: #dfe4ea; depthTest: false; transparent: true; " position="0.15 0.15 0.000001"></a-mixin>


    </a-assets>

    <a-entity id="player"></a-entity>
    <a-entity id="actor"></a-entity>

    <!-- oculus hands -->
    <a-entity id="leftHand" oculus-touch-controls="hand: left" visible="false"></a-entity>
    <a-entity id="rightHand" oculus-touch-controls="hand: right" visible="false" blink-controls></a-entity>


</a-scene>


<script>

    // All asets have loaded
    document.querySelector('#scene-assets').addEventListener('loaded', function() {

        // Don't show HTML component (chat) while loader is active
        if(document.getElementById("chat-wrapper-el").getAttribute('data-visible') === 'true') {
            document.getElementById("chat-wrapper-el").style.visibility = 'visible';
        }

    });

    let selectAvatarType = (val) => {

        let radioVal = val ? val : document.querySelector('input[name="avatar-radios"]:checked').value;

        document.getElementById('cameraA').setAttribute('player-info', 'avatarType', radioVal);
        if (radioVal === 'rpm'){
            document.getElementById('rpm-iframe').hidden = false;
        }
    }

    // Ready player me iframe code
    const rpm_iframe = document.getElementById('rpm-iframe');

    const subdomain = 'vrodos'; // Replace with your custom subdomain
    rpm_iframe.src = `https://${subdomain}.readyplayer.me/avatar?frameApi`;

    window.addEventListener('message', subscribe);
    document.addEventListener('message', subscribe);

    function subscribe(event) {
        const json = parseRPMEvent(event);

        if (json?.source !== 'readyplayerme') {
            return;
        }

        // Susbribe to all events sent from Ready Player Me once frame is ready
        if (json.eventName === 'v1.frame.ready') {
            rpm_iframe.contentWindow.postMessage(
                JSON.stringify({
                    target: 'readyplayerme',
                    type: 'subscribe',
                    eventName: 'v1.**'
                }),
                '*'
            );
        }

        // Get avatar GLB URL
        // Now add it in Aframe canvas
        if (json.eventName === 'v1.avatar.exported') {

            document.getElementById('rpm-iframe').hidden = true;

            // Update remote
            document.getElementById('cameraA').setAttribute('player-info', 'gltf', json.data.url);

        }

        // Get user id
        if (json.eventName === 'v1.user.set') {
            console.log(`User with id ${json.data.id} set: ${JSON.stringify(json)}`);
        }
    }

    function parseRPMEvent(event) {
        try {
            return JSON.parse(event.data);
        } catch (error) {
            return null;
        }
    }


    const api_pattern_single = {
        ThresholdMin: 0.106,
        ThresholdMax: 0.13,
        red: 48, green: 146, blue: 89,
        w: 1, h: 0.75,
        x: 0, y: 0, z: 0,
        rx: 0, ry: 0, rz: 0
    };

    const api_pattern_singleMin = {
        ThresholdMinLow: 0,
        ThresholdMaxLow: 0,
        redLow: 0,
        greenLow: 0,
        blueLow: 0,
        wLow: 0.1,
        hLow: 0.1,
        xLow: -100000,
        yLow: -100000,
        zLow: -100000,
        rxLow: -100,
        ryLow: -100,
        rzLow: -100
    };
    const api_pattern_singleMax = {
        ThresholdMinHigh: 0.4,
        ThresholdMaxHigh: 0.4,
        redHigh: 255,
        greenHigh: 255,
        blueHigh: 255,
        wHigh: 5,
        hHigh: 5,
        xHigh: 100000,
        yHigh: 100000,
        zHigh: 100000,
        rxHigh: 100,
        ryHigh: 100,
        rzHigh: 100
    };
    const api_pattern_singleStep = {
        ThresholdMinStep: 0.001,
        ThresholdMaxStep: 0.001,
        redStep: 1,
        greenStep: 1,
        blueStep: 1,
        wStep: 0.05,
        hStep: 0.05,
        xStep: 10,
        yStep: 10,
        zStep: 10,
        rxStep: 0.1,
        ryStep: 0.1,
        rzStep: 0.1
    };

    let btStatusControls = document.getElementById('obtainStatusAndSetSizeControls');
    btStatusControls.addEventListener('click', function () {

        let entities = window.NAF.connection.entities.entities;
        let panelsSizeControlsDiv = document.getElementById('panelsSizeControlsDiv');

        /* Clear Panels Size  Controls */
        panelsSizeControlsDiv.replaceChildren([]);

        /* DestroyGui */
        try {
            console.log("destroying");
            if (btStatusControls.gui) {
                btStatusControls.gui.destroy();
            }
        }
        catch (e) {
            console.log(e);
        }

        btStatusControls.gui = new dat.GUI({ width: 200 });

        let elementsDatGui = [];
        let videoUserGui = [];

        let nActor = 0;

        if (entities) {

            /* Canvas Size Controls */
            let panel = {};
            for (let e in entities) {

                let h = window.NAF.connection.entities.entities[e].childNodes[1].getAttribute('height');
                if (h) {
                    nActor++;

                    /*  Thresholds Green */
                    videoUserGui[e] = btStatusControls.gui.addFolder(e);

                    /*  Panels  */
                    panel[e] = window.NAF.connection.entities.entities[e].childNodes[0].id === "videoPlaneGreen" ?
                        window.NAF.connection.entities.entities[e].childNodes[0] :
                        window.NAF.connection.entities.entities[e].childNodes[1];

                    elementsDatGui[e] = [];
                    for (let a in api_pattern_single) {

                        let L = a + "Low";
                        let H = a + "High";
                        let S = a + "Step";

                        elementsDatGui[e][a] = videoUserGui[e].add(api_pattern_single, a, api_pattern_singleMin[L], api_pattern_singleMax[H], api_pattern_singleStep[S]);

                        if (a[0] === 'w'
                            || a[0] === 'h'
                            || a[0] === 'x'
                            || a[0] === 'y'
                            || a[0] === 'z'
                            || a.substring(0, 2) === 'rx'
                            || a.substring(0, 2) === 'ry'
                            || a.substring(0, 2) === 'rz') {

                            elementsDatGui[e][a].panelaki = panel[e];
                            elementsDatGui[e][a].domElement.pName = e;

                            switch (a[0]) {
                                case 'w':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[5].panelaki;
                                        p.setAttribute('width', api_pattern_single[this.property]);
                                    });
                                    break;
                                case 'h':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[6].panelaki;
                                        p.setAttribute('height', api_pattern_single[this.property]);
                                    });
                                    break;
                                case 'x':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[7].panelaki;
                                        p.getAttribute('position').x = api_pattern_single[this.property] / 10000;
                                    });
                                    break;
                                case 'y':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[8].panelaki;
                                        p.getAttribute('position').y = api_pattern_single[this.property] / 10000;
                                    });
                                    break;
                                case 'z':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[9].panelaki;
                                        p.getAttribute('position').z = api_pattern_single[this.property] / 10000;
                                    });
                                    break;


                            }

                            switch (a.substring(0, 2)) {

                                case 'rx':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[10].panelaki;
                                        let xStr = api_pattern_single[this.property];
                                        let yStr = p.getAttribute('rotation').y;
                                        let zStr = p.getAttribute('rotation').z;
                                        p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                    });
                                    break;

                                case 'ry':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[11].panelaki;
                                        let xStr = p.getAttribute('rotation').x;
                                        let yStr = api_pattern_single[this.property];
                                        let zStr = p.getAttribute('rotation').z;
                                        p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                    });
                                    break;

                                case 'rz':
                                    elementsDatGui[e][a].onChange(function () {
                                        let p = this.panelaki !== undefined ? this.panelaki : btStatusControls.gui.__folders[this.domElement.parentElement.pName].__controllers[12].panelaki;
                                        let xStr = p.getAttribute('rotation').x;
                                        let yStr = p.getAttribute('rotation').y;
                                        let zStr = api_pattern_single[this.property];
                                        p.setAttribute('rotation', xStr + " " + yStr + " " + zStr);
                                    });
                                    break;
                            }

                        } else {
                            elementsDatGui[e][a].onChange(function () {
                                let domAffected = document.getElementsByClassName("videoPlaneGreenClass")[elementsDatGui[e][a].nActor];
                                domAffected.setAttribute("networked-video-source", this.property, api_pattern_single[this.property]);
                            });
                        }
                        elementsDatGui[e][a].nActor = nActor - 1;
                    }
                }
            }
        }
    });

    /* Called by Networked-Aframe when connected to server */
    function onConnect() {

        let OnConnectDate = new Date();

        const screenBtnEle = document.getElementById('screen-btn-sendscreen');
        screenBtnEle.addEventListener('click', function () {
            navigator.mediaDevices.getDisplayMedia({
                preferCurrentTab: true,
                selfBrowserSurface: 'include',
                audio: true
            }).then((stream) => {
                NAF.connection.adapter.addLocalMediaStream(stream, "screen");
            });
        });
    }

    let record_button = document.getElementById('start-recording-btn');
    let video_preview = document.getElementById('video-preview');

    let download_button = document.getElementById('download-recording-btn');
    download_button.style.visibility = 'hidden';
    let upload_button = document.getElementById('upload-recording-btn');
    let capture_label = document.getElementById('captured-video-label');
    let recording = document.getElementById('recording');

    function startRecording(stream) {

        let recorder = new MediaRecorder(stream);
        let data = [];

        recorder.ondataavailable = event => data.push(event.data);
        recorder.start();

        let stopped = new Promise((resolve, reject) => {
            recorder.onstop = resolve;
            recorder.onerror = event => reject(event.name);
        });

        return Promise.all([
            stopped
        ]).then(() => data);
    }

    function stopRecording(stream) {
        stream.getTracks().forEach(track => track.stop());
        record_button.disabled = false;
        download_button.style.visibility = 'visible';
        upload_button.disabled = false;
    }

    let recordedBlob;

    record_button.addEventListener("click", function () {

        capture_label.innerHTML = '';

        navigator.mediaDevices.getDisplayMedia({
            preferCurrentTab: true,
            selfBrowserSurface: 'include',
            systemAudio: 'include',
            video: {
                cursor: 'never'
            },
            audio: true
        }).then(stream => {

            record_button.disabled = true;
            download_button.style.visibility = 'hidden';

            video_preview.style.display = 'block';
            video_preview.srcObject = stream;
            download_button.href = stream;
            video_preview.captureStream = video_preview.captureStream || video_preview.mozCaptureStream;

            stream.getVideoTracks()[0].onended = function () {
                video_preview.style.display = 'none';
                stopRecording(video_preview.srcObject);
            };

            return new Promise(resolve => video_preview.onplaying = resolve);
        }).then(() => startRecording(video_preview.captureStream()))
            .then(recordedChunks => {

                recordedBlob = new Blob(recordedChunks, { type: "video/webm" });
                recording.src = URL.createObjectURL(recordedBlob);
                download_button.style.visibility = 'visible';
                download_button.href = recording.src;
                download_button.download = "RecordedVideo.webm";

                upload_button.href = recording.src;
                capture_label.innerHTML = "Recorded " + formatBytes(recordedBlob.size) + " of " +
                    recordedBlob.type + " media.";

            });
    }, false);

    upload_button.addEventListener("click", function () {

        upload_button.disabled = true;

        const mv_url = document.getElementById('node-url-input').value;
        const mv_token = document.getElementById('node-token-input').value;
        const mv_project_id = document.getElementById('mv-project-id-input').value;

        const video_file = new File([recordedBlob], 'vrodos-' + recordedBlob.size + '.webm', {
            type: recordedBlob.type,
        });

        let formData = new FormData();
        formData.append('file', video_file);

        fetch(mv_url + '/dam/assets?description=' + 'Recorded video from VROdos' + '&externalTool=VRodos', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${mv_token}`
            },
            body: formData
        }).then(function (response) {
            if (response.ok) {
                return response.json();
            } else {
                upload_button.disabled = false;
                alert("There has been a problem uploading your video to MediaVerse platform");
            }
        }).then(function (data) {

            fetch(mv_url + '/dam/project/' + mv_project_id + '/projectOutput', {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${mv_token}`
                },
                body: JSON.stringify({
                    "projectOutput": [data.key]
                })
            }).then(function (response) {
                upload_button.disabled = false;
                if (response.ok) {
                    alert('The video has been successfully uploaded to MediaVerse!');
                } else {
                    alert("There has been a problem uploading your video to MediaVerse platform");
                    console.log(response.json());
                }
            })
        });
    });

    /* x button show clacket. key code 88 */
    document.addEventListener('keydown', function (e) {
        if (e.keyCode === 88) {
            document.getElementById('actionsDiv').style.display = 'block';

            if (document.getElementsByClassName('dg ac')[0]) {
                document.getElementsByClassName('dg ac')[0].style.display = 'block';
            }

            if (document.cancelFullScreen) {
                document.cancelFullScreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.webkitCancelFullScreen) {
                document.webkitCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }
    });

    /* Make full screen and hide controls */
    let director_controls = document.getElementById("toggle_controls");
    director_controls.onclick = function () {

        document.getElementById('actionsDiv').style.display = 'none';

        if (document.getElementsByClassName('dg ac')[0]) {
            document.getElementsByClassName('dg ac')[0].style.display = 'none';
        }

        let elem = document.body;

        if (elem.requestFullScreen) {
            elem.requestFullScreen();
        } else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
        } else if (elem.webkitRequestFullScreen) {
            elem.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
        } else if (elem.msRequestFullscreen) {
            elem.msRequestFullscreen();
        }
    };

    let formatBytes = (bytes, decimals = 2) => {
        if (!+bytes) return '0 Bytes'

        const k = 1024
        const dm = decimals < 0 ? 0 : decimals
        const sizes = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']

        const i = Math.floor(Math.log(bytes) / Math.log(k))

        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`
    };

    window.ntExample = {
        randomColor: () => {
            return '#' + new THREE.Color(Math.random(), Math.random(), Math.random()).getHexString();
        }
    };

</script>

<!-- This will change the glb materials -->
<!-- <script src="js/glb_material_changer.js"></script> -->

<script src="js/components/chat_component.js"></script>
</body>

</html>